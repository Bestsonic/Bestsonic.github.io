{"meta":{"title":"星之夢","subtitle":"不要轻率地评判他人，否则便容易犯下傲慢之罪。","description":"欢迎来到星相馆，这里有不论何时永远不会消失的繁星，漫天的星星正在等着大家的到来。","author":"Zhong Yibo","url":"http://bestsonic.github.io"},"pages":[{"title":"","date":"2017-07-30T07:14:01.000Z","updated":"2017-07-30T06:08:30.000Z","comments":false,"path":"categories/index.html","permalink":"http://bestsonic.github.io/categories/index.html","excerpt":"","text":""},{"title":"","date":"2017-07-30T07:14:01.000Z","updated":"2017-07-30T06:07:56.000Z","comments":false,"path":"tags/index.html","permalink":"http://bestsonic.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ZooKeeper-入门","slug":"ZooKeeper-入门","date":"2017-07-30T08:30:00.000Z","updated":"2017-07-30T10:06:21.000Z","comments":true,"path":"2017/07/30/ZooKeeper-入门/","link":"","permalink":"http://bestsonic.github.io/2017/07/30/ZooKeeper-入门/","excerpt":"随着计算机系统规模越来越大，集中式计算机系统的成本指数级提高，并且存在单点问题。分布式系统渐渐取代了原有的集中式系统。 分布式系统有如下几个特征：分布性、对等性、并发性、缺乏全局时钟、故障总会发生。由于分布式系统依赖网络，\b\b经常会存在如下几个问题：通信异常、网络分区、三态、节点故障。 本文主要介绍分布式系统\b一致性相关的基础知识。","text":"随着计算机系统规模越来越大，集中式计算机系统的成本指数级提高，并且存在单点问题。分布式系统渐渐取代了原有的集中式系统。 分布式系统有如下几个特征：分布性、对等性、并发性、缺乏全局时钟、故障总会发生。由于分布式系统依赖网络，\b\b经常会存在如下几个问题：通信异常、网络分区、三态、节点故障。 本文主要介绍分布式系统\b一致性相关的基础知识。 事务及事务的特性 什么是事务事务(Transaction)是由一系列对系统中数据进行访问与更新的操作锁组成的一个程序执行逻辑单元(Unit)，狭义上的事务特指数据库事务。事务是保证数据一致性的方法。 事务的特性事务具有四个特性，分别是原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)、持久性(Durability)，简称事务的ACID特性。 原子性事务的原子性指事务必须是一个原子的操作序列单元。事务中包含的各项操作执行过程中，仅有两种状态：全部执行成功或全部不执行。 一致性事务的一致性是指一个事务在执行前和执行之后，数据库都必须处于一致的状态。事务的执行结果必须使数据库从一个一致性状态转变到另一个一致性状态。 隔离性事务的隔离性是指在并发环境中，并发的事务是相互隔离的，一个事务的执行不能被其他事务干扰。 在标准的SQL规范中，定义了4个事务的隔离级别，不同的隔离级别对事务的处理不同。 Read Uncommitted 该隔离级别允许脏读，其隔离级别最低。如果一个事务正在处理某一个数据，并对其进行了更新，但同时尚未完成事务，此时另外一个事务也能够访问变更后的数据。 Read Committed 该隔离级别只允许获取已经被提交的数据。该事务禁止脏读，但允许不可重复读取。例如：在事务B过程中，执行了事务A和事务C，分别产生了结果10和20，则在事务B中能够读取到两种结果。 Repeatable Read 该隔离级别保证在事务处理过程中，多次读取同一个数据时，其值都和事务开始时刻一直。该事务禁止不可重复读和脏读，但是可能出现幻读。 Serializable 该隔离级别是最严格的事务隔离级别，要求所有事务都被串行化执行，事务只能一个接着一个执行，不能并发执行。 持久性事务的持久性指一个事务一旦提交，它对数据库中对应数据的状态变更就应该是永久的。即使发生系统崩溃或宕机，在重新启动后，仍然可以恢复到事务成功结束时的状态。 分布式事务分布式事务是指事务的参与者、支持事务的服务器、资源服务器以及事务管理器分别位于分布式系统的不同节点之上。一个分布式事务可以看做是由多个分布式的操作序列组成的，例如取款服务和存款服务，通常可以把这一系列分布式操作序列成为子事务。 CAP和BASE理论CAP理论CAP理论告诉我们，一个分布式系统不可能同时满足一致性(C:Consistency)、可用性(A:Availability)和分区容忍性(P:Partition tolerance)这三个基本需求，最多只能同时满足其中的两项。 一致性数据在多个副本之间是否能够保持一致的特性，不存在脏读的情况。 可用性系统提供的服务必须一直处于可用的状态，对于用户的每一个操作请求总是能够在有限的时间内返回结果。 分区容忍性分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非整个网络环境都发生故障。 由于分布式系统必定会出现网络的异常情况，因此分区容忍性是分布式系统必然需要解决的问题。所以，架构师往往会根据业务特点在一致性和可用性中间寻求平衡。 BASE理论BASE理论是Basically Available、Soft state和Eventually consistent三个短语的缩写。BASE是对CAP中一致性和可用性权衡的结果。其核心思想是即使无法做到强一致性，每个应用也可以根据自身的业务特点，采用适当的方式使系统达到最终一致性。 基本可用指分布式系统在出现不可预知故障的时候，允许损失部分可用性。体现在响应时间上的损失(响应时间变长)或功能上的损失(大促高峰时，部分消费者被引导到降级页面)。 弱状态指允许系统中的数据存在中间状态，并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程存在延时。 最终一致性指系统中所有数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。最终一致性是特殊的弱一致性。 在实际工程实践中，最终一致性存在以下五类变种: 因果一致性(Causal consistency) 因果一致性是指，如果进程A在更新完某个数据项后通知了进程B，那么进程B之后对该数据项的访问都应该能够获得到进程A更新后的最新直，并且如果进程B要对该数据项进行更新操作的话，务必基于进程A更新后的最新值，不能发生丢失更新的情况。 读己之所写(Read your writes) 读己之所写是指，进程A更新一个数据项之后，它自己总是能够访问到更新过的最新值。这是一种特殊的因果一致性。 会话一致性(Session consistency) 会话一致性将对系统数据的访问过程框定在一个会话当中，系统能保证在同一个有效的会话中实现”读己之所写”的一致性。即执行更新操作之后，客户端能够在同一个会话中始终读取到该数据项的最新值。 单调读一致性(Monotonic read consisitency) 单调读一致性是指如果一个进程从系统中读取出一个数据项的某个值后，那么系统对于该进程后续的任何数据访问都不应该返回更旧的值。 单调写一致性(Monotonic write consistency) 单调协议执行是指，一个系统需要能够保证来自同一个进程的写操作被顺序地执行。 许多现代的关系型数据库中都采用了最终一致性模型。例如同步和异步方式来实现主备数据复制技术。 小结总的来说，BASE理论面向的是大型高可用可扩展分布式系统，和传统事务的ACID特性是相反的，它提出通过牺牲强一致性来获得可用性，并允许数据在一段时间内是不一致性，但在有限的时间内会达到一致性状态。 计算机从集中式项分布式变革的过程中，出现了分布式网络、分布式事务和分布式数据一致性等在内的一系列问题与挑战，同时也催生了ACID、CAP、BASE等经典理论的快速发展。具体的分布式系统架构设计中，ACID特性往往会与BASE理论结合使用。","categories":[],"tags":[{"name":"ZooKeeper","slug":"ZooKeeper","permalink":"http://bestsonic.github.io/tags/ZooKeeper/"},{"name":"Paxos","slug":"Paxos","permalink":"http://bestsonic.github.io/tags/Paxos/"},{"name":"一致性","slug":"一致性","permalink":"http://bestsonic.github.io/tags/一致性/"}]},{"title":"再出发","slug":"再出发","date":"2017-07-30T07:30:00.000Z","updated":"2017-07-30T07:46:03.000Z","comments":true,"path":"2017/07/30/再出发/","link":"","permalink":"http://bestsonic.github.io/2017/07/30/再出发/","excerpt":"距离上次写Blog已经非常非常久了，但是这段时间并没有虚度，在工作岗位上，遇到了许多人，许多事，学习了许多新知识，也交了许多学费。 为什么选择这个时候重新开始呢？一方面，正式入职近3周，总结一年的实习，虽然每天都非常忙碌，但鲜有能值得称道的工程或项目，大多是满足客户提出的需求，并没有深刻地了解业务，这导致做了很多没有效果的工作；另一方面，在完成毕业设计到正式入职的这段时间中，部门也发生了很多事情，组织架构的调整，一些同事的离去，晋升的不力，使我一度迷茫。所以我希望做点什么，学点什么，来摆脱目前的颓势。 我仔细地审视自己，扪心自问，我希望未来在工作岗位上成为什么样的人？我的职业规划是怎样的？怎样提升自己，朝着这个目标前进？这些悬而未决的问题的背后，是对自我的迷失。也是，你很了解你自己吗？你能够很容易地说出内心的诉求吗？你不了解自己，不知道自己想要什么，又如何能够规划出未来的方向呢？ 先引用前辈们的思考，作为借鉴吧。随着阅历的丰富，相信未来会不断清晰起来吧。","text":"距离上次写Blog已经非常非常久了，但是这段时间并没有虚度，在工作岗位上，遇到了许多人，许多事，学习了许多新知识，也交了许多学费。 为什么选择这个时候重新开始呢？一方面，正式入职近3周，总结一年的实习，虽然每天都非常忙碌，但鲜有能值得称道的工程或项目，大多是满足客户提出的需求，并没有深刻地了解业务，这导致做了很多没有效果的工作；另一方面，在完成毕业设计到正式入职的这段时间中，部门也发生了很多事情，组织架构的调整，一些同事的离去，晋升的不力，使我一度迷茫。所以我希望做点什么，学点什么，来摆脱目前的颓势。 我仔细地审视自己，扪心自问，我希望未来在工作岗位上成为什么样的人？我的职业规划是怎样的？怎样提升自己，朝着这个目标前进？这些悬而未决的问题的背后，是对自我的迷失。也是，你很了解你自己吗？你能够很容易地说出内心的诉求吗？你不了解自己，不知道自己想要什么，又如何能够规划出未来的方向呢？ 先引用前辈们的思考，作为借鉴吧。随着阅历的丰富，相信未来会不断清晰起来吧。 如何确定自己做技术还是管理 从标题来看是个很简单很朴实的问题，大部分技术人员在工作3年、5年以后都会面临这个问题，如果没有面临，说明你平常思考的太少，或者你危机要降临了。 本文讨论的是通常意义的计算机相关技术人员的个人职业发展规划，如果是个人创业或者其他目标追求不在此列，我只是描述大部分普普通通的计算机工程师的问题。 中国是个官本位思想很重的国家，所有主流意识认为能够当官或者做管理的人才是有出头的，才是有出息的，才是王道，才会被亲朋好友同事同学瞧得起，其实，不尽然。 我说点大块的，比如说，如果袁隆平当年做的是管理工作思想政治工作，不是研究杂交水稻，我想包括我在内的看本文的大部分读者，基本都不会存活在这个世界，他本质其实做的是一个技术研究性工作。 往小了说，每个人性格特点兴趣爱好不同，其实有适合不同的职责和岗位。我举个真实的例子，又一次我坐出租车，出租车司机是一个老师傅，他说他开车开了十多年，他跟我闲聊，讲了个他十几年前的故事。师傅以前在一个工厂里上班做技术员，领导觉得他这个技术工作做的不错，准备让他当他们一个小组长，主要是就是监督别人生产的产品是否合格，还有教导产品做的不好的工人改正做的更好，他上任不到3天就不干了，原因很多，比如比如觉得不好意思开口说别人怕得罪人，比如喜欢一个人钻研自己的产品工艺，不喜欢指导别人操作等等，其实核心就是不喜欢管人。然后领导换了另外一个人来做这个小组长，司机师傅技术做自己的技术员，后来发现这个新换的人干的很好，工作井井有条，大家也都很尊重支持他。 故事讲完，这个是个基本真实的故事，反应的就是工作和个人性格和喜好结合的问题。 从上面两个案例来看，做技术还是做管理，最少从几个点出发：是否是自己的目标追求？是否是自己喜欢干的事情？是否能够发挥自己的特长？3年5年后怎么办这个工作是否有持续发展的可能？ 等等，都是我们需要考虑的问题。 有几个点是非常重要的：1.自己性格是适合做技术还是做管理？ 2.做技术或者管理从自身角度出发，几年后是否会有更好的发展？ 3.个人非常迫切或者是希望将来的目标是怎么样的？这里主要就是性格、自己的目标、未来的发展3个点。不过有些因素是致命的，比如说我曾经有个同事，只要一个别人沟通，就一定会吵架云云，那么如果让他做管理，必然会让团队出现问题，但是他一个人做技术不错，很有耐心，也有钻研精神，当然了，也许几年后，他磨练的不错，还能够走管理这条线。 上面总结几点： 需要按照自己性格来因地制宜选择做技术还是做管理 按照目前工作需要和工作能力来决定 按照本子行业的更好的发展规划来决定 按照自己预先设定好的目标来决定 不一定做管理就一定可以出头做技术就一定不能出头 如何做好技术或管理 这里主要是描述做好技术工作和管理工作所需要的主要要求和技能。 现在计算机技术（软件、互联网）方面来看，做技术主要有几个方向： 技术专家 架构师 业务专家 技术专家路线技术专家就是通常称为某个领域或者某项特殊技术的专家，举个例子说，你是一个Java专家，那么从Java基本的语言特性到内部机制，JVM虚拟机等等，你无所不知无所不晓，或者是Oracle专家、MySQL专家，就是你所精通的这个子领域你是非常非常专业的，而且这个子领域学习门槛非常高，不是轻易简单可以弄通的，那么你就成为了这个领域专家，自然，你从学习技术中获得乐趣，也从别人膜拜和处理别人没法处理的问题获得快乐，当然，只要这个你擅长的技术领域一直存在，你的职业就会高枕无忧！当然，需要时刻更新自己的知识。技术专家的核心就是：深入而精通！ 架构师路线架构师就是对某一个技术领域的各个知识点，各种工具都很了解，能够依赖掌握的知识和经验，在做新技术或者是搭建某些业务的时候给出最有效的架构指导，或者在比如性能出现瓶颈的时候迅速可以给出良好的解决方案。架构师的概念很宽泛，软件架构师和互联网体系架构师所需要掌握的技术是完全不同的。举个例子说，你是一个LAMP架构师，那么你会了解Linux、Apache、mysql、PHP的整套工具组合，你也了解相关网站知识，知道各种开源技术，了解各种碰到问题的解决方案，并且你不局限这些，你还能够通过目前掌握的知识，能够延伸解决更复杂的问题，或者在遇见复杂问题的时候给出最有效的建议和方案。架构师的核心就是：技术能力广、经验丰富、解决问题能力强、思路视野比较宽广。 业务专家路线业务专家更多在软件行业，比如说各种ERP系统，或者是某些信息管理类系统，都会存在不同行业的业务差别巨大。比如烟草行业和电信行业就不是一个业务模型，而且这些模型不是随便一个人就可以了解的，别人可能需要花费1年或者好几年才能去深入了解各种业务差别和细节，所以你就是整个了解技术和业务的专家，随便不能被取代，实际表现的职位可能是需求工程师或者是架构师的角色出现，实际掌握的技能是偏业务的，但是整个角色跟一般的市场、产品经理角色不同，而是了解技术的业务专家！只要行业不挂，该类软件需求存在，自然饭碗可保！ 从上面来看，其实架构师是很多人追求的，技术专家就需要个人性格和对计算机技术的非常热爱才行，业务专家一般在软件行业，各个业务不同，需求和差别也是很大的。 管理路线管理路线跟技术路线要求的技能是完全不同的，一般我们说的管理会偏向于技术管理，但是如果越往上走，可能针对某个领域的管理能力就会越弱化，比如你之前是技术总监需要关注一些大方面的技术方向，等你变成副总裁以后，可能对技术方面的要求就会完全弱化了，更多只是管理能力了。我们从技术管理角度来看，至少要求懂技术、会管理，这都是宽泛的概念，不同公司对管理的定义不一样，比如有些公司的技术管理角色可能只是一个架构师的角色，或者是一个项目分配的角色，这些都是偏颇。 一般的技术管理来说是能够懂技术，在某些重大技术决策上面会有一些个人的见解，另外就是懂管理，比如很多软素质，沟通能力、向上汇报向下传达能力、团队管理能力、人员培养能力、上下游部门合作把控能力、业务需求沟通能力、在重大问题的决断能力、长远目标和规划能力、执行力等等。我觉得最基础的能力是沟通能力、判断力、执行力、推动能力等，沟通能力渗透到每一个地方，不论是上下游合作，业务和需求讨论，还是团队成员思想教育，都需要沟通能力，管理非常重要的就是沟通能力。另外一个就是判断力，比如你需要能够判断某个业务的重要程度、某个成员的个人能力情况、某个业务需求的合理和实现成本等等，这些是建立在经验或思考后进行准确判断的基础上面。执行力是我们对业务的支持，或者是对上级老板下达工作要求的快速行动，都是执行力的范畴。 综合来看，管理能力跟技术能力的要求差别还是比较大，所以对岗位要求也是不同，实际对人的性格等要求也是不同的。 而且，其实技术的每个阶段和管理的每个阶段对技能的要求都是不同的，我上面只是简单列举几条，仅供参考。 如何去做 首先，需要明确自己想要什么，就跟你在公司面试的时候一般HR会问你：你的职业规划是什么？ 是的，你想要做技术还是做管理，都跟你的目标和职业规划有关，每个人的实际情况不同，性格不同，目标就不同，不过尽量坚持自己想做的事情，哪怕一时半会看不出效果，长期总是能够看到效果的。 其次，是你明确了想要什么，那么就按照想要的设定目标，并且把目标分解（拆解）成为可以实现的各个步骤，设定好每个步骤所需要的技能，那么就针对性的学习提高，不论是从培训中提高，还是从实践中提高。 最后，你只要勤勤恳恳，按照目标去一步步递进，我相信你总会实现自己的目标的！ 不过我一般还是建议尽量做跟自己性格和自己喜欢的事情想符合的选择，这样你不会活的那么累，并且会获得良好的发展和未来。 祝福每一位看见本文的技术工作者都能够有可以实现的职业规划和美好的未来！！","categories":[],"tags":[{"name":"随笔","slug":"随笔","permalink":"http://bestsonic.github.io/tags/随笔/"}]},{"title":"搭建Git服务器","slug":"搭建Git服务器","date":"2015-08-31T01:30:00.000Z","updated":"2017-07-30T07:00:03.000Z","comments":true,"path":"2015/08/31/搭建Git服务器/","link":"","permalink":"http://bestsonic.github.io/2015/08/31/搭建Git服务器/","excerpt":"在本教程中，您可以了解如何通过 Gitolite 和 Gitweb 工具来安装一个Git服务器，该服务器可通过 ssh 和 http 协议进行访问。 Gitolite 工具能够实现用户管理功能。 Gitweb 工具提供一个仓库列表的 Web 界面。 Apache 工具提供智能 http 服务(Smart HTTP)，用于连接Git服务器。","text":"在本教程中，您可以了解如何通过 Gitolite 和 Gitweb 工具来安装一个Git服务器，该服务器可通过 ssh 和 http 协议进行访问。 Gitolite 工具能够实现用户管理功能。 Gitweb 工具提供一个仓库列表的 Web 界面。 Apache 工具提供智能 http 服务(Smart HTTP)，用于连接Git服务器。 准备 Git 项目网站: http://git-scm.com/ 服务器配置Arch: i686 / x86_64Packages : Gitolite and GitwebGit server ip address : 10.82.59.55 Note:如果能进行域名解析，你也可以使用 Git 服务器主机名。 摘要:搭建一个私有 Git 服务器。该服务器能通过ssh和http链接。这里，Gitweb用于浏览仓库细节，而Gitolite则用于Git服务器的用户/组管理。 Note: 该文章中，# 表示 root用户，$ 表示 git 用户。 配置本机PC (非Git服务器) 搭建步骤如下: 首先从你的PC开始，注意不是你的Git服务器。 创建 RSA key。 创建RSA密钥对登陆你的PC主机，该机用于远程管理Git服务器。 如果你的主目录下不存在 .ssh 目录，说明你的 SSH 公钥/私钥对尚未创建。可以用这个命令创建： ssh-keygen -t rsa -C “Git-Admin” 该命令会在用户主目录下创建 .ssh 目录，并在其中创建两个文件： id_rsa 私钥文件。 是基于 RSA 算法创建。该私钥文件要妥善保管，不要泄漏。 id_rsa.pub 公钥文件。 和 id_rsa 文件是一对儿，该文件作为公钥文件，可以公开。 Note：Git-Admin 为你的pc客户端的Git用户名。 复制公钥到服务器使用 scp 将 id_rsa.pub 复制到 Git服务器上。 \\$ scp ~/.ssh/id_rsa.pub root@ip-address-of-git-server:~ 配置Git服务器端 以 root 登陆 Git 服务器。 服务器基本配置安装 Git http 和 perl 依赖。 # yum -y install git httpd perl-Time-HiRes perl-Data-Dumper 创建 git 用户，并更改它的 gid 和 uid # useradd git# usermod -u 600 git# groupmod -g 600 git 将得到的 id_rsa.pub 改为 Git-Admin.pub。同时将其 mv 到 /home/git 。将它的用户/组更改为git。 # mv /root/id_rsa.pub /home/git/Git-Admin.pub ; chown git:git /home/git/Git-Admin.pub 配置Gitolite 登陆git用户，从 github.com 克隆 gitolite。 # su -l git \\$ whoami(The command will show you log in with which user) \\$ echo \\$HOME(The command will show what is your home directory) \\$ git clone git://github.com/sitaramc/gitolite 接着创建 bin 目录和设置 Git-Admin 账户 Note: 将 id_rsa.pub 改为 Git-Admin.pub 的原因是： the Gitolite will provide same name of user in gitolite.conf file as the name of .pub file.for eg. if I use only id_rsa.pub then “id_rsa” user will be created. 因此，当你需要通过 ssh 添加一个 Git 服务器的用户时，你需要将该用户的 id_rsa.pub 重命名为 user-name.pub。比如，joe的 rsa file 应该被改为 joe.pub (id_rsa.pub –rename–&gt; joe.pub) \\$ mkdir -p /home/git/bin\\$ gitolite/install -ln\\$ gitolite setup -pk Git-Admin.pub 退出 git 用户。登陆 root 。核对一下 suexec 的默认值。 \\$ exit(logout from git user) # suexec -v 我的Git服务器 suexec 细节. [root@gitserver ~]# suexec -V -D AP_DOC_ROOT=”/var/www” -D AP_GID_MIN=100 -D AP_HTTPD_USER=”apache” -D AP_LOG_EXEC=”/var/log/httpd/suexec.log” -D AP_SAFE_PATH=”/usr/local/bin:/usr/bin:/bin” -D AP_UID_MIN=500 -D AP_USERDIR_SUFFIX=”public_html” 创建 bin 目录 （in /var/www ）(Why /var/www ? because I got the detail from suexec -V,see parameter AP_DOC_ROOT) 下面的命令将创建一个 /var/www/bin 文件夹（with permission 0755 and owner &amp;group is git） # install -d -m 0755 -o git -g git /var/www/bin 在 /var/www/bin/ 创建一个 gitolite-suexec-wrapper.sh 。然后保存退出。 vi /var/www/bin/gitolite-suexec-wrapper.sh #!/bin/bash # # Suexec wrapper for gitolite-shell # export GIT_PROJECT_ROOT=&quot;/home/git/repositories&quot; export GITOLITE_HTTP_HOME=&quot;/home/git&quot; exec \\${GITOLITE_HTTP_HOME}/gitolite/src/gitolite-shell 接着修改 /var/www/bin 和 gitolite-suexec-wrapper.sh 的权限 # chown -R git:git /var/www/bin# chmod 750 /var/www/bin/gitolite-suexec-wrapper.sh# chmod 755 /var/www/bin 将 /home/git/.gitolite.rc 里的 UMASK 0077 修改为 UMASK =&gt; 0027 vi /home/git/.gitolite.rc UMASK =&gt; 0027, 安装GitWeb安装 GitWeb yum install gitweb 默认情况下，Gitweb 会安装在 /var/www/git 目录。（目录下包含 gitweb.cgi 文件）修改 /var/www/git 目录。如下所示： # mv /var/www/git /var/www/html/gitweb 修改 /var/www/html/gitweb 所有者 # chown -R git:git /var/www/html/gitweb 下面是我服务器的细节： [root@gitserver html]# chown -R git:git gitweb/[root@gitserver html]# ls -ld gitweb/drwxr-xr-x 2 git git 4096 Jun 1 12:36 gitweb/[root@gitserver html]# ls -la gitweb/total 252drwxr-xr-x 2 git git 4096 Jun 1 12:36 .drwxr-xr-x 3 root root 4096 Jun 1 12:34 ..-rw-r–r– 1 git git 115 Apr 24 2010 git-favicon.png-rw-r–r– 1 git git 207 Apr 24 2010 git-logo.png-rwxr-xr-x 1 git git 204754 Jun 1 12:36 gitweb.cgi-rw-r–r– 1 git git 8379 Apr 24 2010 gitweb.css-rw-r–r– 1 git git 24142 Apr 24 2010 gitweb.js[root@gitserver html]# 编辑文件 /etc/gitweb.conf 修改其中的两个变量: \\$projectroot 和 \\$projects_list vi /etc/gitweb.conf our \\$projectroot = &quot;/home/git/repositories/&quot;; our \\$projects_list = &quot;/home/git/projects.list&quot;; 修改文件 /var/www/html/gitweb/gitweb.cgi 并修改其中的两个变量: \\$projectroot 和 \\$projects_list vi /var/www/html/gitweb/gitweb.cgi our \\$projectroot = &quot;/home/git/repositories&quot;; our \\$projects_list = &quot;/home/git/projects.list&quot;; 创建一个虚假文件夹（dummy folder git）。注意加上 permissions,owner and group限制。 # install -d -m 0755 -o apache -g apache /var/www/git (This is dummy one) 配置Apache打开 /etc/httpd/conf/httpd.conf 。在最后一行加上 VirtualHost 配置。 Note: 如果你的 Git 服务器有使用主机名和 FQDN，你就可以将 ServerName 和 ServerAlias 前的 # 去掉。然后，写上你的主机信息。ServerAdmin表示管理员的联系邮箱。 12345678910111213141516171819202122232425262728&lt;VirtualHost *:80&gt;# You can comment out the below 3 lines and put correct value as per your server information# ServerName gitserver.example.com# ServerAlias gitserverServerAdmin youremailid@example.comDocumentRoot /var/www/git&lt;Directory /var/www/git&gt; Options None AllowOverride none Order allow,deny Allow from all&lt;/Directory&gt;SuexecUserGroup git gitScriptAlias /git/ /var/www/bin/gitolite-suexec-wrapper.sh/ScriptAlias /gitmob/ /var/www/bin/gitolite-suexec-wrapper.sh/&lt;Location /git&gt; AuthType Basic AuthName \"Git Access\" Require valid-user AuthUserFile /etc/httpd/conf/git.passwd&lt;/Location&gt;&lt;/VirtualHost&gt; 修改 /etc/httpd/conf.d/git.conf 。该文件在安装 Gitweb 时自动创建。下面我将对 Git Server 进行部分修改。重点！不能落下一步。 123456789101112131415vi /etc/httpd/conf.d/git.confAlias /gitweb /var/www/html/gitweb&lt;Directory /var/www/html/gitweb&gt; Options +ExecCGI AddHandler cgi-script .cgi DirectoryIndex gitweb.cgi&lt;/Directory&gt;&lt;Location /gitweb&gt; AuthType Basic AuthName \"Git Access\" Require valid-user AuthUserFile /etc/httpd/conf/git.passwd&lt;/Location&gt; 下面我们将创建 Apcahe 的管理员的用户密码。当你第一次创建用户时，我们需要使用 -c 符号。-c 表示创建一个新的文件。详细参见htpasswd的man帮助。 # htpasswd -c /etc/httpd/conf/git.passwd admin 对于添加一个用户或者修改存在的用户密码，不需要添加 -c # htpasswd /etc/httpd/conf/git.passwd user1 # htpasswd /etc/httpd/conf/git.passwd testuser 当你设置一个 htpasswd user 或 passwd时，需要重启或重载 apache 。chkconfig 命令使 apache 服务开机启动。设置为 runelevel 3 and 5 ### On CentOS 6.x / RHEL 6.x /etc/init.d/httpd restart;chkconfig httpd on ### On CentOS 7.x / RHEL 7.x systemctl restart httpd ; systemctl enable httpd 所有配置已完成，可以使用 Git 服务器了。 使用 Git 服务器 GitWeb webpage使用以下格式访问（网页会要求你输入你设置的 htpasswd 的用户和密码） http://ip-address-of-git-server/gitweb/ 以 http方式 克隆仓库使用命令（网页会要求你输入你设置的 htpasswd 的用户和密码） \\$ git clone http://ip-address-of-git-server-OR-FQDN/git/repo-name.git 上面两个命令的不同之处， 克隆 Git 仓库时在url中使用 Git 访问网页时，使用 Gitweb Note: 如果你想要学习为什么使用 Git 或 Gitweb，请打开 git.conf 和 httpd.conf 文件。 git.conf中 “Alias /gitweb /var/www/html/gitweb” httpd.conf中 “ScriptAlias /git/ /var/www/bin/gitolite-suexec-wrapper.sh/” 然后将testing.git克隆到桌面上或其他目录 \\$ cd ~/Desktop \\$ git clone http://ip-address-of-git-server-OR-FQDN/git/testing.git 管理 Git 服务器的用户和用户组为了管理 Git 服务器的用户和用户组，你需要克隆 Gitolite-admin 到你的pc上。注意，该PC必须是你在 Step A 和 Step B中使用的PC。 这里我将复制 Gitolite-admin 到桌面。 \\$ cd ~/Desktop \\$ git config –global user.name “Git-Admin” \\$ git config –global user.email “youremailid@example.com” \\$ git clone git@GitServerIP-or-FQDN:gitolite-admin.git 通过配置 gitolite.conf 文件来管理访问 Git 服务器的用户和用户组。当你对 gitolite.conf 文件进行了如何修改，你都需要进行 git push 操作 下面是我电脑的配置参考 sharad@mypc:~/Desktop/gitolite-admin/conf\\$ pwd/home/sharad/Desktop/gitolite-admin/conf sharad@sharad-sapplica:~/Desktop/gitolite-admin/conf\\$ cat gitolite.conf repo gitolite-admin RW+ = Git-Admin repo testing RW+ = @all R = git daemon sharad@mypc:~/Desktop/gitolite-admin/conf\\$ 这里 R 和 W 的意义： R = Read W = Write 现在将这些修改 push 到 Git服务器上。 \\$ cd ~/Desktop/gitolite-admin/conf \\$ ls -l gitolite.conf \\$ git add gitolite.conf \\$ git commit -m “first commit” \\$ git push origin master 在 Git 服务器中创建仓库我们创建一个 “linux” 仓库 以 root 方式登陆 Git 服务器，然后切换到 git 用户 # su -l git \\$ cd repositories \\$ mkdir linux.git \\$ cd linux.git \\$ git –bare init \\$ git update-server-info Update projects.list 文件 更新 projects.list 文件。在该文件中添加你刚刚新建的 Git 仓库名。 vi /home/git/projects.list testing.git linux.git 完成 update 操作后，你就可以在 GitWeb 上看到新的 repository 了。 如下图所示 git_server Note: 当 Gitweb 出现 404 – No projects found 时，需要关闭 SElinux 。 从源代码安装Git 有人觉得从源码安装 Git 更实用，因为你能得到最新的版本。 二进制安装程序倾向于有一些滞后，当然近几年 Git 已经成熟，这个差异不再显著。 如果你想从源码安装 Git，需要安装 Git 依赖的库：curl、zlib、openssl、expat，还有libiconv。 如果你的系统上有 yum （如 Fedora）或者 apt-get（如基于 Debian 的系统），可以使用以下命令之一来安装最小化的依赖包来编译和安装 Git 的二进制版： \\$ sudo yum install curl-devel expat-devel gettext-devel \\ openssl-devel zlib-devel \\$ sudo apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \\ libz-dev libssl-dev 为了能够添加更多格式的文档（如 doc, html, info），你需要安装以下的依赖包： \\$ sudo yum install asciidoc xmlto docbook2x \\$ sudo apt-get install asciidoc xmlto docbook2x 当你安装好所有的必要依赖，你可以继续从几个地方来取得最新发布版本的 tar 包。 你可以从 Kernel.org 网站获取，网址为 https://www.kernel.org/pub/software/scm/git ，或从 GitHub 网站上的镜像来获得，网址为 https://github.com/git/git/releases 。 通常在 GitHub 上的是最新版本，但 kernel.org 上包含有文件下载签名，如果你想验证下载正确性的话会用到。 接着，编译并安装： \\$ tar -zxf git-2.0.0.tar.gz \\$ cd git-2.0.0 \\$ make configure \\$ ./configure –prefix=/usr \\$ make all doc info \\$ sudo make install install-doc install-html install-info 完成后，你可以使用 Git 来获取 Git 的升级： \\$ git clone git://git.kernel.org/pub/scm/git/git.git Git服务端的基本配置 我们来看看如何配置服务器端的 SSH 访问。 本例中，我们将使用 authorized_keys 方法来对用户进行认证。 同时我们假设你使用的操作系统是标准的 Linux 发行版，比如 Ubuntu。 首先，创建一个操作系统用户 git，并为其建立一个 .ssh 目录。 \\$ sudo adduser git\\$ su git\\$ cd\\$ mkdir .ssh &amp;&amp; chmod 700 .ssh\\$ touch .ssh/authorized_keys &amp;&amp; chmod 600 .ssh/authorized_keys 接着，我们需要为系统用户 git 的 authorized_keys 文件添加一些开发者 SSH 公钥。 假设我们已经获得了若干受信任的公钥，并将它们保存在临时文件中。 与前文类似，这些公钥看起来是这样的： \\$ cat /tmp/id_rsa.john.pubssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCB007n/ww+ouN4gSLKssMxXnBOvf9LGt4LojG6rs6hPB09j9R/T17/x4lhJA0F3FR1rP6kYBRsWj2aThGw6HXLm9/5zytK6Ztg3RPKK+4kYjh6541NYsnEAZuXz0jTTyAUfrtU3Z5E003C4oxOj6H0rfIF1kKI9MAQLMdpGW1GYEIgS9EzSdfd8AcCIicTDWbqLAcU4UpkaX8KyGlLwsNuuGztobF8m72ALC/nLF6JLtPofwFBlgc+myivO7TCUSBdLQlgMVOFq1I2uPWQOkOWQAHukEOmfjy2jctxSDBQ220ymjaNsHT4kgtZg2AYYgPqdAv8JggJICUvax2T9va5 gsg-keypair 将这些公钥加入系统用户 git 的 .ssh 目录下 authorized_keys 文件的末尾： \\$ cat /tmp/id_rsa.john.pub &gt;~/.ssh/authorized_keys\\$ cat /tmp/id_rsa.josie.pub &gt;~/.ssh/authorized_keys\\$ cat /tmp/id_rsa.jessica.pub &gt;~/.ssh/authorized_keys 现在我们来为开发者新建一个空仓库。可以借助带 –bare 选项的 git init 命令来做到这一点，该命令在初始化仓库时不会创建工作目录： \\$ cd /opt/git\\$ mkdir project.git\\$ cd project.git\\$ git init –bareInitialized empty Git repository in /opt/git/project.git/ 接着，John、Josie 或者 Jessica 中的任意一人可以将他们项目的最初版本推送到这个仓库中，他只需将此仓库设置为项目的远程仓库并向其推送分支。 请注意，每添加一个新项目，都需要有人登录服务器取得 shell，并创建一个裸仓库。 我们假定这个设置了 git 用户和 Git 仓库的服务器使用 gitserver 作为主机名。 同时，假设该服务器运行在内网，并且你已在 DNS 配置中将 gitserver 指向此服务器。那么我们可以运行如下命令（假定 myproject 是已有项目且其中已包含文件）： # on John’s computer\\$ cd myproject\\$ git init\\$ git add .\\$ git commit -m ‘initial commit’\\$ git remote add origin git@gitserver:/opt/git/project.git\\$ git push origin master 此时，其他开发者可以克隆此仓库，并推回各自的改动，步骤很简单： \\$ git clone git@gitserver:/opt/git/project.git\\$ cd project\\$ vim README\\$ git commit -am ‘fix for the README file’\\$ git push origin master 通过这种方法，你可以快速搭建一个具有读写权限、面向多个开发者的 Git 服务器。 需要注意的是，目前所有（获得授权的）开发者用户都能以系统用户 git 的身份登录服务器从而获得一个普通 shell。 如果你想对此加以限制，则需要修改 passwd 文件中（git 用户所对应）的 shell 值。 借助一个名为 git-shell 的受限 shell 工具，你可以方便地将用户 git 的活动限制在与 Git 相关的范围内。该工具随 Git 软件包一同提供。 如果将 git-shell 设置为用户 git 的登录 shell（login shell），那么用户 git 便不能获得此服务器的普通 shell 访问权限。 若要使用 git-shell，需要用它替换掉 bash 或 csh，使其成为系统用户的登录 shell。 为进行上述操作，首先你必须确保 git-shell 已存在于 /etc/shells 文件中： \\$ cat /etc/shells # see if git-shell is already in there. If not…\\$ which git-shell # make sure git-shell is installed on your system.\\$ sudo vim /etc/shells # and add the path to git-shell from last command 现在你可以使用 chsh 命令修改任一系统用户的 shell： \\$ sudo chsh git # and enter the path to git-shell, usually: /usr/bin/git-shell 这样，用户 git 就只能利用 SSH 连接对 Git 仓库进行推送和拉取操作，而不能登录机器并取得普通 shell。 如果试图登录，你会发现尝试被拒绝，像这样： \\$ ssh git@gitserverfatal: Interactive git shell is not enabled.hint: ~/git-shell-commands should exist and have read and execute access.Connection to gitserver closed. 现在，网络相关的 Git 命令依然能够正常工作，但是开发者用户已经无法得到一个普通 shell 了。 正如输出信息所提示的，你也可以在 git 用户的家目录下建立一个目录，来对 git-shell 命令进行一定程度的自定义。 比如，你可以限制掉某些本应被服务器接受的 Git 命令，或者对刚才的 SSH 拒绝登录信息进行自定义，这样，当有开发者用户以类似方式尝试登录时，便会看到你的信息。 要了解更多有关自定义 shell 的信息，请运行 git help shell。 参考 How to install own git server with ssh and http access by using gitolite and gitweb in CentOS","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"http://bestsonic.github.io/tags/Git/"}]},{"title":"Java笔记-JDBC","slug":"SpringMVC-入门","date":"2015-08-11T02:42:00.000Z","updated":"2017-07-30T07:00:52.000Z","comments":true,"path":"2015/08/11/SpringMVC-入门/","link":"","permalink":"http://bestsonic.github.io/2015/08/11/SpringMVC-入门/","excerpt":"Spring Web 模型-视图-控制器(MVC)框架围绕DispatcherServlet设计，它将请求分发到处理程序中，带有配置处理器的映射，视图解决方案，时区、主题解决方案和文件上传下载的支持。默认处理器基于@Controller和@RequestMapping注解，提供了一个广泛而灵活的处理方法。随着Spring3.0的引入，@Controller也增加了新特性，例如允许通过@PathVariable注解建立RESTful的网页和应用等。 SpringMVC的视图解决方案很灵活。一个Controller通常负责使用数据来准备一个Map模型，接着选择一个视图名称(也可以直接写入响应流和完整的请求)。视图名称可以通过文件扩展名或是Accept类型的协议头、或者是bean的名称，一个属性文件，甚至是一个用户自定义的ViewResolver(视图解析器)来确定。模型是一个Map接口，它支持视图技术的完全抽象。你可以直接基于模板生成技术来整合模型和视图，如JSP，Velocity，Freemarker或直接生成XML，JSON，Atom或者许多其他类型的内容。一个模型Map可以很容易的转换成合适的类型，例如JSP请求属性，一个Velocity模板模型。","text":"Spring Web 模型-视图-控制器(MVC)框架围绕DispatcherServlet设计，它将请求分发到处理程序中，带有配置处理器的映射，视图解决方案，时区、主题解决方案和文件上传下载的支持。默认处理器基于@Controller和@RequestMapping注解，提供了一个广泛而灵活的处理方法。随着Spring3.0的引入，@Controller也增加了新特性，例如允许通过@PathVariable注解建立RESTful的网页和应用等。 SpringMVC的视图解决方案很灵活。一个Controller通常负责使用数据来准备一个Map模型，接着选择一个视图名称(也可以直接写入响应流和完整的请求)。视图名称可以通过文件扩展名或是Accept类型的协议头、或者是bean的名称，一个属性文件，甚至是一个用户自定义的ViewResolver(视图解析器)来确定。模型是一个Map接口，它支持视图技术的完全抽象。你可以直接基于模板生成技术来整合模型和视图，如JSP，Velocity，Freemarker或直接生成XML，JSON，Atom或者许多其他类型的内容。一个模型Map可以很容易的转换成合适的类型，例如JSP请求属性，一个Velocity模板模型。 SpringMVC的HelloWorld SpringMVC搭建Web工程的典型步骤如下： 加入SpringMVC的jar包，或在Maven工程的pom.xml加入如下依赖： 123456&lt;!-- http://mvnrepository.com/artifact/org.springframework/spring-webmvc --&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt; 在Web工程的WEB.xml中加入配置文件: 12345678&lt;servlet&gt; &lt;servlet-name&gt;project name&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;project name&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 注意: 这里可以指定SpringMVC对应的配置文件的路径，即加入标签， 默认的配置文件路径为WEB-INF/${project name}-servlet.xml。 编辑SpringMVC的配置文件:123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-3.1.xsd\"&gt; &lt;context:component-scan base-package=\"base-package\"/&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\"/&gt; &lt;property name=\"suffix\" value=\".jsp\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 注意: 这里的base-package指的是SpringMVC需要扫描的包的路径，主要用于将使用了注解的Spring Bean创建，并注入到Spring的IOC容器中。而后面的InternalResourceViewResolver则是视图资源处理器，这里指定了前缀和后缀，在Controller中","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://bestsonic.github.io/tags/Java/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://bestsonic.github.io/tags/SpringMVC/"}]},{"title":"图解数字签名","slug":"图解数字签名","date":"2015-08-02T02:45:00.000Z","updated":"2017-07-30T07:00:18.000Z","comments":true,"path":"2015/08/02/图解数字签名/","link":"","permalink":"http://bestsonic.github.io/2015/08/02/图解数字签名/","excerpt":"本文转载字阮一峰的日志。 今天，我读到一篇好文章。它用图片通俗易懂地解释了，”数字签名”（digital signature）和”数字证书”（digital certificate）到底是什么。 我对这些问题的理解，一直是模模糊糊的，很多细节搞不清楚。读完这篇文章后，发现思路一下子就理清了。为了加深记忆，我把文字和图片都翻译出来了。","text":"本文转载字阮一峰的日志。 今天，我读到一篇好文章。它用图片通俗易懂地解释了，”数字签名”（digital signature）和”数字证书”（digital certificate）到底是什么。 我对这些问题的理解，一直是模模糊糊的，很多细节搞不清楚。读完这篇文章后，发现思路一下子就理清了。为了加深记忆，我把文字和图片都翻译出来了。 Bob有两把钥匙，一把是公钥，一把是私钥。 Bob的公钥对于需要它的任何人都能得到，但是他的私钥则自己保留。密钥（公钥和私钥）是用来加密信息的。加密信息的过程意味着“混淆打乱”，以至于只有拥有合适密钥的人才能将其再次变得可读。Bob的两把钥匙中，任何一把用来加密数据，另一把就能解密数据。 Bob将他的公钥送给了他的朋友Pat, Doug, Susan。每人一把公钥。 Susan要给Bob写一封保密的信。她写完后用Bob的公钥加密，就可以达到保密的效果。Bob的任一同事可能都可以拿到Susan已经加密的信息，但是没有Bob的私钥，这些数据都是没用的。 Bob收信后，用私钥解密，就看到了信件内容。这里要强调的是，只要Bob的私钥不泄露，这封信就是安全的，即使落在别人手里，也无法解密。 利用他的私钥和适当的软件，Bob放置了数字签名在文档和一些数据中。这个数字签名是Bob放在数据中的，是对于Bob而言唯一的“标识”，是非常难以捏造的。并且，这个签名能够确保当数据发生任何变动时都会被发现。 对文档签名时，Bob的软件会将数据揉碎压缩成仅仅几行，这个过程被称为“HASH校验”，形成的几行则被称作信息的摘要。（直接将信息摘要还原成原始的数据信息是不可能的） 然后Bob的软件再利用他的私钥加密信息的摘要，这个结果就是数字签名。 最后，Bob将这个数字签名与信息文档放在一块。所有的数据已经被有所标识了。 现在Bob把文档传递给了Pat。首先Pat利用Bob的公钥将签名解密还原为信息的摘要。如果这可行，说明文档确实是Bob加密的，因为只有他自己才有自己的密钥。 Pat的软件同样将信息数据加密为摘要，如果这个摘要跟刚才解密出来的摘要相同，那么Pat就可以断定签名过的数据没有被修改过。 这时出现了Doug，他企图欺骗Pat。Doug偷偷使用了Bob的电脑，换掉了Bob的公钥和私钥，并用假的私钥生成了数字签名，发给了Pat。**这时怎样判断来自Bob的公钥是否可靠呢？ 碰巧的是，Susan工作在公司的CA中心（证书认证），Susan可以对Bob的公钥和他的一些资料信息一并签名，简单地为Bob制作一个数字证书。证书中心用自己的私钥，对鲍勃的公钥和一些相关信息一起加密，生成”数字证书”（Digital Certificate）。 鲍勃拿到数字证书以后，就可以放心了。以后再给苏珊写信，只要在签名的同时，再附上数字证书就行了。 现在Bob的同事能够通过检测Bob受信任的证书来确保他们拥有的公钥确实是Bob的。事实上，Bob公司中没有人会接受没有Susan生成证书的那个签名。这个就给了Susan撤销私钥被泄露的数字证书的权利，而这几乎是不太可能的。Susan的CA证书验证则被广泛的接受。我们接着说Bob把已经签名的文档发给了Pat。为了验证在文档上的数字签名，Pat首先借助软件用Susan（即CA）的公钥来检测Bob文档上的证书。如果顺利解开了证书则证明是Susan生成的它。解开证书之后，Pat可以通过联系CA中心，与Bob证书上的信息对照，以检查文档是否被修改过。然后，pat从证书中拿到Bob的公钥，用它来检测Bob的签名。如果Bob的公钥能够顺利解开签名，Pat就可以确定这个签名是利用Bob的私钥生成的，同时也匹配了Susan颁发的证书公钥。并且，如果签名是对照的，也说明了Doug不可能修改了文档内容。 下面，我们看一个应用”数字证书”的实例：https协议。这个协议主要用于网页加密。 首先，客户端向服务器发出加密请求。 服务器用自己的私钥加密网页以后，连同本身的数字证书，一起发送给客户端。 客户端（浏览器）的”证书管理器”，有”受信任的根证书颁发机构”列表。客户端会根据这张列表，查看解开数字证书的公钥是否在列表之内。 如果数字证书记载的网址，与你正在浏览的网址不一致，就说明这张证书可能被冒用，浏览器会发出警告。 如果这张数字证书不是由受信任的机构颁发的，浏览器会发出另一种警告。 如果数字证书是可靠的，客户端就可以使用证书中的服务器公钥，对信息进行加密，然后与服务器交换加密信息。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://bestsonic.github.io/tags/Java/"},{"name":"安全","slug":"安全","permalink":"http://bestsonic.github.io/tags/安全/"}]},{"title":"Java笔记-安全","slug":"Java笔记-安全","date":"2015-08-01T02:45:00.000Z","updated":"2017-07-30T07:00:29.000Z","comments":true,"path":"2015/08/01/Java笔记-安全/","link":"","permalink":"http://bestsonic.github.io/2015/08/01/Java笔记-安全/","excerpt":"安全性是Java应用程序的非功能性需求的重要组成部分，如同其它的非功能性需求一样，安全性很容易被开发人员所忽略。当然，对于Java EE的开发人员来说，安全性的话题可能没那么陌生，用户认证和授权可能是绝大部分Web应用都有的功能。类似Spring Security这样的框架，也使得开发变得更加简单。本文并不会讨论Web应用的安全性，而是介绍Java安全一些底层和基本的内容。","text":"安全性是Java应用程序的非功能性需求的重要组成部分，如同其它的非功能性需求一样，安全性很容易被开发人员所忽略。当然，对于Java EE的开发人员来说，安全性的话题可能没那么陌生，用户认证和授权可能是绝大部分Web应用都有的功能。类似Spring Security这样的框架，也使得开发变得更加简单。本文并不会讨论Web应用的安全性，而是介绍Java安全一些底层和基本的内容。 认证 用户认证是应用安全性的重要组成部分，其目的是确保应用的使用者具有合法的身份。 Java安全中使用术语主体（Subject）来表示访问请求的来源。一个主体可以是任何的实体。一个主体可以有多个不同的身份标识（Principal）。比如一个应用的用户这类主体，就可以有用户名、身份证号码和手机号码等多种身份标识。除了身份标识之外，一个主体还可以有公开或是私有的安全相关的凭证（Credential），包括密码和密钥等。 典型的用户认证过程是通过登录操作来完成的。在登录成功之后，一个主体中就具备了相应的身份标识。Java提供了一个可扩展的登录框架，使得应用开发人员可以很容易的定制和扩展与登录相关的逻辑。登录的过程由LoginContext启动。在创建LoginContext的时候需要指定一个登录配置（Configuration）的名称。该登录配置中包含了登录所需的多个LoginModule的信息。每个LoginModule实现了一种登录方式。当调用LoginContext的login方法的时候，所配置的每个LoginModule会被调用来执行登录操作。如果整个登录过程成功，则通过getSubject方法就可以获取到包含了身份标识信息的主体。开发人员可以实现自己的LoginModule来定制不同的登录逻辑。 每个LoginModule的登录方式由两个阶段组成。第一个阶段是在login方法的实现中。这个阶段用来进行必要的身份认证，可能需要获取用户的输入，以及通过数据库、网络操作或其它方式来完成认证。当认证成功之后，把必要的信息保存起来。如果认证失败，则抛出相关的异常。第二阶段是在commit或abort方法中。由于一个登录过程可能涉及到多个LoginModule。LoginContext会根据每个LoginModule的认证结果以及相关的配置信息来确定本次登录是否成功。LoginContext用来判断的依据是每个LoginModule对整个登录过程的必要性，分成必需、必要、充分和可选这四种情况。如果登录成功，则每个LoginModule的commit方法会被调用，用来把身份标识关联到主体上。如果登录失败，则LoginModule 的abort方法会被调用，用来清除之前保存的认证相关信息。 在LoginModule进行认证的过程中，如果需要获取用户的输入，可以通过CallbackHandler和对应的Callback来完成。每个Callback可以用来进行必要的数据传递。典型的启动登录的过程如下： 123456public Subject login() throws LoginException &#123; TextInputCallbackHandler callbackHandler = new TextInputCallbackHandler(); LoginContext lc = new LoginContext(\"SmsApp\", callbackHandler); lc.login(); return lc.getSubject();&#125; 这里的SmsApp是登录配置的名称，可以在配置文件中找到。该配置文件的内容也很简单。 123SmsApp &#123; security.login.SmsLoginModule required;&#125;; 这里声明了使用security.login.SmsLoginModule这个登录模块，而且该模块是必需的。配置文件可以通过启动程序时的参数java.security.auth.login.config来指定，或修改JVM的默认设置。下面看看SmsLoginModule的核心方法login和commit。 12345678910111213141516171819202122public boolean login() throws LoginException &#123; TextInputCallback phoneInputCallback = new TextInputCallback(\"Phone number: \"); TextInputCallback smsInputCallback = new TextInputCallback(\"Code: \"); try &#123; handler.handle(new Callback[] &#123;phoneInputCallback, smsInputCallback&#125;); &#125; catch (Exception e) &#123; throw new LoginException(e.getMessage()); &#125; String code = smsInputCallback.getText(); boolean isValid = code.length() &gt; 3; //此处只是简单的进行验证。 if (isValid) &#123; phoneNumber = phoneInputCallback.getText(); &#125; return isValid;&#125;public boolean commit() throws LoginException &#123; if (phoneNumber != null) &#123; subject.getPrincipals().add(new PhonePrincipal(phoneNumber)); return true; &#125; return false;&#125; 这里使用了两个TextInputCallback来获取用户的输入。当用户输入的编码有效的时候，就把相关的信息记录下来，此处是用户的手机号码。在commit方法中，就把该手机号码作为用户的身份标识与主体关联起来。 权限控制 在验证了访问请求来源的合法身份之后，另一项工作是验证其是否具有相应的权限。权限由Permission及其子类来表示。每个权限都有一个名称，该名称的含义与权限类型相关。某些权限有与之对应的动作列表。比较典型的是文件操作权限FilePermission，它的名称是文件的路径，而它的动作列表则包括读取、写入和执行等。Permission类中最重要的是implies方法，它定义了权限之间的包含关系，是进行验证的基础。 权限控制包括管理和验证两个部分。管理指的是定义应用中的权限控制策略，而验证指的则是在运行时刻根据策略来判断某次请求是否合法。策略可以与主体关联，也可以没有关联。策略由Policy来表示，JDK提供了基于文件存储的基本实现。开发人员也可以提供自己的实现。在应用运行过程中，只可能有一个Policy处于生效的状态。验证部分的具体执行者是AccessController，其中的checkPermission方法用来验证给定的权限是否被允许。在应用中执行相关的访问请求之前，都需要调用checkPermission方法来进行验证。如果验证失败的话，该方法会抛出AccessControlException异常。 JVM中内置提供了一些对访问关键部分内容的访问控制检查，不过只有在启动应用的时通过参数-Djava.security.manager启用了安全管理器之后才能生效，并与策略相配合。 与访问控制相关的另外一个概念是特权动作。特权动作只关心动作本身所要求的权限是否具备，而并不关心调用者是谁。比如一个写入文件的特权动作，它只要求对该文件有写入权限即可，并不关心是谁要求它执行这样的动作。特权动作根据是否抛出受检异常，分为PrivilegedAction和PrivilegedExceptionAction。这两个接口都只有一个run方法用来执行相关的动作，也可以向调用者返回结果。通过AccessController的doPrivileged方法就可以执行特权动作。 Java安全使用了保护域的概念。每个保护域都包含一组类、身份标识和权限，其意义是在当访问请求的来源是这些身份标识的时候，这些类的实例就自动具有给定的这些权限。保护域的权限既可以是固定，也可以根据策略来动态变化。ProtectionDomain类用来表示保护域，它的两个构造方法分别用来支持静态和动态的权限。一般来说，应用程序通常会涉及到系统保护域和应用保护域。不少的方法调用可能会跨越多个保护域的边界。因此，在AccessController进行访问控制验证的时候，需要考虑当前操作的调用上下文，主要指的是方法调用栈上不同方法所属于的不同保护域。这个调用上下文一般是与当前线程绑定在一起的。通过AccessController的getContext方法可以获取到表示调用上下文的AccessControlContext对象，相当于访问控制验证所需的调用栈的一个快照。在有些情况下，会需要传递此对象以方便在其它线程中进行访问控制验证。 考虑下面的权限验证代码： 123456789Subject subject = new Subject();ViewerPrincipal principal = new ViewerPrincipal(\"Alex\");subject.getPrincipals().add(principal);Subject.doAsPrivileged(subject, new PrivilegedAction&lt;Object&gt;() &#123; public Object run() &#123; new Viewer().view(); return null; &#125;&#125;, null); 这里创建了一个新的Subject对象并关联上身份标识。通常来说，这个过程是由登录操作来完成的。通过Subject的doAsPrivileged方法就可以执行一个特权动作。Viewer对象的view方法会使用AccessController来检查是否具有相应的权限。策略配置文件的内容也比较简单，在启动程序的时候通过参数java.security.auth.policy指定文件路径即可。 123grant Principal security.access.ViewerPrincipal \"Alex\" &#123; permission security.access.ViewPermission \"CONFIDENTIAL\";&#125;; //这里把名称为CONFIDENTIAL的ViewPermission授权给了身份标识为Alex的主体。 加密、解密与签名 构建安全的Java应用离不开加密和解密。Java的密码框架采用了常见的服务提供者架构，以提供所需的可扩展性和互操作性。该密码框架提供了一系列常用的服务，包括加密、数字签名和报文摘要等。这些服务都有服务提供者接口（SPI），服务的实现者只需要实现这些接口，并注册到密码框架中即可。比如加密服务Cipher的SPI接口就是CipherSpi。每个服务都可以有不同的算法来实现。密码框架也提供了相应的工厂方法用来获取到服务的实例。比如想使用采用MD5算法的报文摘要服务，只需要调用MessageDigest.getInstance(“MD5”)即可。 加密和解密过程中并不可少的就是密钥（Key）。加密算法一般分成对称和非对称两种。对称加密算法使用同一个密钥进行加密和解密；而非对称加密算法使用一对公钥和私钥，一个加密的时候，另外一个就用来解密。不同的加密算法，有不同的密钥。对称加密算法使用的是SecretKey，而非对称加密算法则使用PublicKey和PrivateKey。与密钥Key对应的另一个接口是KeySpec，用来描述不同算法的密钥的具体内容。比如一个典型的使用对称加密的方式(DES)如下： 12345678KeyGenerator generator = KeyGenerator.getInstance(\"DES\");SecretKey key = generator.generateKey();saveFile(\"key.data\", key.getEncoded());Cipher cipher = Cipher.getInstance(\"DES\");cipher.init(Cipher.ENCRYPT_MODE, key);String text = \"Hello World\";byte[] encrypted = cipher.doFinal(text.getBytes());saveFile(\"encrypted.bin\", encrypted); 加密的时候首先要生成一个密钥，再由Cipher服务来完成。可以把密钥的内容保存起来，方便传递给需要解密的程序。 123456byte[] keyData = getData(\"key.data\");SecretKeySpec keySpec = new SecretKeySpec(keyData, \"DES\");Cipher cipher = Cipher.getInstance(\"DES\");cipher.init(Cipher.DECRYPT_MODE, keySpec);byte[] data = getData(\"encrypted.bin\");byte[] result = cipher.doFinal(data); 解密的时候先从保存的文件中得到密钥编码之后的内容，再通过SecretKeySpec获取到密钥本身的内容，再进行解密。 报文摘要的目的在于防止信息被有意或无意的修改。通过对原始数据应用某些算法，可以得到一个校验码。当收到数据之后，只需要应用同样的算法，再比较校验码是否一致，就可以判断数据是否被修改过。相对原始数据来说，校验码长度更小，更容易进行比较。消息认证码（Message Authentication Code）与报文摘要类似，不同的是计算的过程中加入了密钥，只有掌握了密钥的接收者才能验证数据的完整性。 使用公钥和私钥就可以实现数字签名的功能。某个发送者使用私钥对消息进行加密，接收者使用公钥进行解密。由于私钥只有发送者知道，当接收者使用公钥解密成功之后，就可以判定消息的来源肯定是特定的发送者。这就相当于发送者对消息进行了签名。数字签名由Signature服务提供，签名和验证的过程都比较直接。 123456789101112Signature signature = Signature.getInstance(\"SHA1withDSA\");KeyPairGenerator keyGenerator = KeyPairGenerator.getInstance(\"DSA\");KeyPair keyPair = keyGenerator.generateKeyPair();PrivateKey privateKey = keyPair.getPrivate();signature.initSign(privateKey);byte[] data = \"Hello World\".getBytes();signature.update(data);byte[] signatureData = signature.sign(); //得到签名PublicKey publicKey = keyPair.getPublic();signature.initVerify(publicKey);signature.update(data);boolean result = signature.verify(signatureData); //进行验证 验证数字签名使用的公钥可以通过文件或证书的方式来进行发布。 安全套接字连接 在各种数据传输方式中，网络传输目前使用较广，但是安全隐患也更多。安全套接字连接指的是对套接字连接进行加密。加密的时候可以选择对称加密算法。但是如何在发送者和接收者之间安全的共享密钥，是个很麻烦的问题。如果再用加密算法来加密密钥，则成为了一个循环问题。非对称加密算法则适合于这种情况。私钥自己保管，公钥则公开出去。发送数据的时候，用私钥加密，接收者用公开的公钥解密；接收数据的时候，则正好相反。这种做法解决了共享密钥的问题，但是另外的一个问题是如何确保接收者所得到的公钥确实来自所声明的发送者，而不是伪造的。为此，又引入了证书的概念。证书中包含了身份标识和对应的公钥。证书由用户所信任的机构签发，并用该机构的私钥来加密。在有些情况下，某个证书签发机构的真实性会需要由另外一个机构的证书来证明。通过这种证明关系，会形成一个证书的链条。而链条的根则是公认的值得信任的机构。只有当证书链条上的所有证书都被信任的时候，才能信任证书中所给出的公钥。 日常开发中比较常接触的就是HTTPS，即安全的HTTP连接。大部分用Java程序访问采用HTTPS网站时出现的错误都与证书链条相关。有些网站采用的不是由正规安全机构签发的证书，或是证书已经过期。如果必须访问这样的HTTPS网站的话，可以提供自己的套接字工厂和主机名验证类来绕过去。另外一种做法是通过keytool工具把证书导入到系统的信任证书库之中。 1234567URL url = new URL(\"https://localhost:8443\");SSLContext context = SSLContext.getInstance(\"TLS\");context.init(new KeyManager[] &#123;&#125;, new TrustManager[] &#123;new MyTrustManager()&#125;, new SecureRandom());HttpsURLConnection connection = (HttpsURLConnection) url.openConnection();connection.setSSLSocketFactory(context.getSocketFactory());connection.setHostnameVerifier(new MyHostnameVerifier()); 这里的MyTrustManager实现了X509TrustManager接口，但是所有方法都是默认实现。而MyHostnameVerifier实现了HostnameVerifier接口，其中的verify方法总是返回true。 参考资料 Java安全体系结构 Java密码框架（JCA）参考指南 Java认证和授权服务（JAAS）参考指南 Java安全套接字扩展（JSSE）参考指南","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://bestsonic.github.io/tags/Java/"},{"name":"安全","slug":"安全","permalink":"http://bestsonic.github.io/tags/安全/"}]},{"title":"Java笔记-IO流","slug":"Java笔记-IO流","date":"2015-07-29T01:30:00.000Z","updated":"2017-07-30T07:00:35.000Z","comments":true,"path":"2015/07/29/Java笔记-IO流/","link":"","permalink":"http://bestsonic.github.io/2015/07/29/Java笔记-IO流/","excerpt":"Java流在处理上分为字符流和字节流。字符流单元处理 2 个字节的 Unicode 字符，分别操作字符、字符数组或字符串(char)，而字节流单元处理 1 个字节，操作字节和字节数组(byte)。 Java 内用 Unicode 编码存储字符，字符流处理类负责其他编码的字符流和 java 内 Unicode 字符流之间的转换。而类 InputStreamReader 和 OutputStreamWriter 处理字符流和字节流的转换。字符流（一次可以处理一个缓冲区）一次操作比字节流（一次一个字节）效率高。","text":"Java流在处理上分为字符流和字节流。字符流单元处理 2 个字节的 Unicode 字符，分别操作字符、字符数组或字符串(char)，而字节流单元处理 1 个字节，操作字节和字节数组(byte)。 Java 内用 Unicode 编码存储字符，字符流处理类负责其他编码的字符流和 java 内 Unicode 字符流之间的转换。而类 InputStreamReader 和 OutputStreamWriter 处理字符流和字节流的转换。字符流（一次可以处理一个缓冲区）一次操作比字节流（一次一个字节）效率高。 以字节为导向的 Stream InputStream 和 OutputStream 是两个 abstact 类，对于字节为导向的 stream 都扩展这两个基类。 InputStream InputStream 是所有的输入字节流的父类，它是一个抽象类。 ByteArrayInputStream、StringBufferInputStream、FileInputStream 是三种基本的介质流，它们分别从Byte 数组、StringBuffer、和本地文件中读取数据。PipedInputStream 是从与其它线程共用的管道中读取数据，与Piped 相关的知识后续单独介绍。 ObjectInputStream 和所有FilterInputStream 的子类都是装饰流（装饰器模式的主角）。 ByteArrayInputStream – 把内存中的一个缓冲区作为 InputStream 使用. 构造器: (A) ByteArrayInputStream(byte[]) 创建一个新字节数组输入流（ByteArrayInputStream），它从指定字节数组中读取数据（使用 byte作为其缓冲区数组）。 (B) ByteArrayInputStream(byte[], int, int) 创建一个新字节数组输入流，它从指定字节数组中读取数据。 mark: 该字节数组未被复制 StringBufferInputStream – 把一个 String 对象作为 InputStream. 构造器: StringBufferInputStream(String) 根据据指定串创建一个读取数据的输入流串。 注释：不推荐使用 StringBufferInputStream 方法。 此类不能将字符正确的转换为字节。 同 JDK 1.1 版中的类似，从一个串创建一个流的最佳方法是采用StringReader类。 FileInputStream – 把一个文件作为 InputStream ，实现对文件的读取操作. 构造器: (A) FileInputStream(File name) 创建一个输入文件流，从指定的 File 对象读取数据。 (B) FileInputStream(FileDescriptor) 创建一个输入文件流，从指定的文件描述器读取数据。 (C) FileInputStream(String name) 创建一个输入文件流，从指定名称的文件读取数据。 方法: read() 从当前输入流中读取一字节数据，返回值为int，防止返回值出现-1。 read(byte[]) 将当前输入流中 b.length 个字节数据读到一个字节数组中。 read(byte[], int, int) 将输入流中 len 个字节数据读入一个字节数组中。 PipedInputStream – 实现了 pipe 的概念，主要在线程中使用. 管道输入流是指一个通讯管道的接收端。 一个线程通过管道输出流发送数据，而另一个线程通过管道输入流读取数据，这样可实现两个线程间的通讯。 构造器: PipedInputStream() 创建一个管道输入流，它还未与一个管道输出流连接。 PipedInputStream(PipedOutputStream) 创建一个管道输入流 , 它已连接到一个管道输出流。 SequenceInputStream – 把多个 InputStream 合并为一个 InputStream. “序列输入流”类允许应用程序把几个输入流连续地合并起来，并且使它们像单个输入流一样出现。每个输入流依次被读取，直到到达该流的末尾。然后“序列输入流”类关闭这个流并自动地切换到下一个输入流。 构造器: SequenceInputStream(Enumeration) 创建一个新的序列输入流，并用指定的输入流的枚举值初始化它。 SequenceInputStream(InputStream, InputStream) 创建一个新的序列输入流，初始化为首先 读输入流s1, 然后读输入流s2。 OutputSteam IO 中输出字节流的继承图可见上图，可以看出： OutputStream 是所有的输出字节流的父类，它是一个抽象类。 ByteArrayOutputStream、FileOutputStream 是两种基本的介质流，它们分别向Byte 数组、和本地文件中写入数据。PipedOutputStream 是向与其它线程共用的管道中写入数据。 ObjectOutputStream 和所有FilterOutputStream 的子类都是装饰流。 ByteArrayOutputStream – 把信息存入内存中的一个缓冲区中 . 该类实现一个以字节数组形式写入数据的输出流。 当数据写入缓冲区时，它自动扩大。用 toByteArray() 和 toString() 能检索数据。 构造器: (A) ByteArrayOutputStream() 创建一个新的字节数组输出流。 (B) ByteArrayOutputStream(int) 创建一个新的字节数组输出流，并带有指定大小字节的缓冲区容量。 方法： toString(String) 根据指定字符编码将缓冲区内容转换为字符串，并将字节转换为字符。 write(byte[], int, int) 将指定字节数组中从偏移量 off 开始的 len 个字节写入该字节数组输出流。 write(int) 将指定字节写入该字节数组输出流。 writeTo(OutputStream) 用 out.write(buf, 0, count) 调用输出流的写方法将该字节数组输出流的全部内容写入指定的输出流参数。 FileOutputStream – 文件输出流是向 File 或 FileDescriptor 输出数据的一个输出流。 构造器: (A) FileOutputStream(File name) 创建一个文件输出流，向指定的 File 对象输出数据。 (B) FileOutputStream(FileDescriptor) 创建一个文件输出流，向指定的文件描述器输出数据。 (C) FileOutputStream(String name) 创建一个文件输出流，向指定名称的文件输出数据。 (D) FileOutputStream(String, boolean) 用指定系统的文件名，创建一个输出文件。 PipedOutputStream – 管道输出流是指一个通讯管道的发送端。 一个线程通过管道输出流发送数据，而另一个线程通过管道输入流读取数据，这样可实现两个线程间的通讯。 构造器: (A) PipedOutputStream() 创建一个管道输出流，它还未与一个管道输入流连接。 (B) PipedOutputStream(PipedInputStream) 创建一个管道输出流，它已连接到一个管道输入流。 字节流的输入与输出的对应 图中蓝色的为主要的对应部分，红色的部分就是不对应部分。紫色的虚线部分代表这些流一般要搭配使用。从上面的图中可以看出Java IO 中的字节流是极其对称的。“存在及合理”我们看看这些字节流中不太对称的几个类吧！ LineNumberInputStream 主要完成从流中读取数据时，会得到相应的行号，至于什么时候分行、在哪里分行是由改类主动确定的，并不是在原始中有这样一个行号。在输出部分没有对应的部分，我们完全可以自己建立一个LineNumberOutputStream，在最初写入时会有一个基准的行号，以后每次遇到换行时会在下一行添加一个行号，看起来也是可以的。好像更不入流了。 PushbackInputStream 的功能是查看最后一个字节，不满意就放入缓冲区。主要用在编译器的语法、词法分析部分。输出部分的BufferedOutputStream 几乎实现相近的功能。 StringBufferInputStream 已经被Deprecated，本身就不应该出现在InputStream 部分，主要因为String 应该属于字符流的范围。已经被废弃了，当然输出部分也没有必要需要它了！还允许它存在只是为了保持版本的向下兼容而已。 SequenceInputStream 可以认为是一个工具类，将两个或者多个输入流当成一个输入流依次读取。完全可以从IO 包中去除，还完全不影响IO 包的结构，却让其更“纯洁”――纯洁的Decorator 模式。 PrintStream 也可以认为是一个辅助工具。主要可以向其他输出流，或者FileInputStream 写入数据，本身内部实现还是带缓冲的。本质上是对其它流的综合运用的一个工具而已。一样可以踢出IO 包！System.out 和System.out 就是PrintStream 的实例！ 以字符为导向的 stream Reader/Writer 以 Unicode 字符为导向的 stream ，表示以 Unicode 字符为单位从 stream 中读取或往 stream 中写入信息。 Reader/Writer 为 abstract 类 以 Unicode 字符为导向的 stream 包括下面几种类型： Reader 在上面的继承关系图中可以看出： Reader 是所有的输入字符流的父类，它是一个抽象类。 CharReader、StringReader 是两种基本的介质流，它们分别将Char 数组、String中读取数据。PipedReader 是从与其它线程共用的管道中读取数据。 BufferedReader 很明显就是一个装饰器，它和其子类负责装饰其它Reader 对象。 FilterReader 是所有自定义具体装饰流的父类，其子类PushbackReader 对Reader 对象进行装饰，会增加一个行号。 InputStreamReader 是一个连接字节流和字符流的桥梁，它将字节流转变为字符流。FileReader 可以说是一个达到此功能、常用的工具类，在其源代码中明显使用了将FileInputStream 转变为Reader 的方法。我们可以从这个类中得到一定的技巧。Reader 中各个类的用途和使用方法基本和InputStream 中的类使用一致。后面会有Reader 与InputStream 的对应关系。 CharArrayReader – 与 ByteArrayInputStream 对应此类实现一个可用作字符输入流的字符缓冲区 构造器: CharArrayReader(char[]) 用指定字符数组创建一个 CharArrayReader。 CharArrayReader(char[], int, int) 用指定字符数组创建一个 CharArrayReader StringReader – 与 StringBufferInputStream 对应其源为一个字符串的字符流。 构造器: StringReader(String) 创建一新的串读取者。 FileReader – 与 FileInputStream 对应 PipedReader – 与 PipedInputStream 对应 Writer 在上面的关系图中可以看出： Writer 是所有的输出字符流的父类，它是一个抽象类。 CharArrayWriter、StringWriter 是两种基本的介质流，它们分别向Char 数组、String 中写入数据。PipedWriter 是向与其它线程共用的管道中写入数据。 BufferedWriter 是一个装饰器为Writer 提供缓冲功能。 PrintWriter 和PrintStream 极其类似，功能和使用也非常相似。 OutputStreamWriter 是OutputStream 到Writer 转换的桥梁，它的子类FileWriter 其实就是一个实现此功能的具体类（具体可以研究一SourceCode）。功能和使用和OutputStream 极其类似，后面会有它们的对应图。 CharArrayWrite – 与ByteArrayOutputStream对应 *StringWrite – 与之对应的以字节为导向的stream FileWrite – 与 FileOutputStream 对应 PipedWrite – 与 PipedOutputStream 对应 中间流InputStreamReader和OutputStreamReader 把一个以字节为导向的 stream 转换成一个以字符为导向的 stream 。 InputStreamReader 类是从字节流到字符流的桥梁：它读入字节，并根据指定的编码方式，将之转换为字符流。 使用的编码方式可能由名称指定，或平台可接受的缺省编码方式。 InputStreamReader 的 read() 方法之一的每次调用，可能促使从基本字节输入流中读取一个或多个字节。 为了达到更高效率，考虑用 BufferedReader 封装 InputStreamReader ， BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); InputStreamReader(InputStream) 用缺省的字符编码方式(默认GBK)，创建一个 InputStreamReader 。 InputStreamReader(InputStream, String) 用已命名的字符编码方式，创建一个 InputStreamReader 。 OutputStreamWriter 将多个字符写入到一个输出流，根据指定的字符编码将多个字符转换为字节。 每个 OutputStreamWriter 合并它自己的 CharToByteConverter, 因而是从字符流到字节流的桥梁。 字符流的输入与输出的对应 字符流与字节流转换 转换流的特点： 其是字符流和字节流之间的桥梁 可对读取到的字节数据经过指定编码转换成字符 可对读取到的字符数据经过指定编码转换成字节 何时使用转换流？ 当字节和字符之间有转换动作时 流操作的数据需要编码或解码时 具体的对象体现： InputStreamReader:字节到字符的桥梁 OutputStreamWriter:字符到字节的桥梁 这两个流对象是字符体系中的成员，它们有转换作用，本身又是字符流，所以在构造的时候需要传入字节流对象进来。 Java IO常用类 File类File类是对文件系统中文件以及文件夹进行封装的对象，可以通过对象的思想来操作文件和文件夹。 File类保存文件或目录的各种元数据信息，包括文件名、文件长度、最后修改时间、是否可读、获取当前文件的路径名，判断指定文件是否存在、获得当前目录中的文件列表，创建、删除文件和目录等方法。 RandomAccessFile类该对象并不是流体系中的一员，其封装了字节流，同时还封装了一个缓冲区（字符数组），通过内部的指针来操作字符数组中的数据。 该对象特点： 该对象只能操作文件，所以构造函数接收两种类型的参数：a.字符串文件路径；b.File对象。 该对象既可以对文件进行读操作，也能进行写操作，在进行对象实例化时可指定操作模式(r,rw) 注意：该对象在实例化时，如果要操作的文件不存在，会自动创建；如果文件存在，写数据未指定位置，会从头开始写，即覆盖原有的内容。可以用于多线程下载或多个线程同时写数据到文件。 Java IO 的一般使用原则 一、按数据来源（去向）分类： 是文件： FileInputStream, FileOutputStream( 字节流 ), FileReader, FileWriter( 字符 ) 是 byte[] ： ByteArrayInputStream, ByteArrayOutputStream( 字节流 ) 是 Char[]: CharArrayReader, CharArrayWriter( 字符流 ) 是 String: StringBufferInputStream, StringBufferOuputStream ( 字节流 )StringReader, StringWriter( 字符流 ) 网络数据流： InputStream, OutputStream,( 字节流 ) Reader, Writer( 字符流 ) 二、按是否格式化输出分： 要格式化输出： PrintStream, PrintWriter 三、按是否要缓冲分： 要缓冲： BufferedInputStream, BufferedOutputStream,( 字节流 ) BufferedReader, BufferedWriter( 字符流 ) 四、按数据格式分： 二进制格式（只要不能确定是纯文本的） : InputStream, OutputStream 及其所有带 Stream 结束的子类 纯文本格式（含纯英文与汉字或其他编码方式）； Reader, Writer 及其所有带 Reader, Writer 的子类 五、按输入输出分： 输入： Reader, InputStream 类型的子类 输出： Writer, OutputStream 类型的子类 六、特殊需要： 从 Stream 到 Reader, Writer 的转换类： InputStreamReader, OutputStreamWriter 对象输入输出： ObjectInputStream, ObjectOutputStream 进程间通信： PipeInputStream, PipeOutputStream, PipeReader, PipeWriter 合并输入： SequenceInputStream 更特殊的需要： PushbackInputStream, PushbackReader, LineNumberInputStream, LineNumberReader 决定使用哪个类以及它的构造进程的一般准则如下（不考虑特殊需要）： 首先，考虑最原始的数据格式是什么：原则四 第二，是输入还是输出：原则五 第三，是否需要转换流：原则六第 1 点 第四，数据来源（去向）是什么：原则一 第五，是否要缓冲：原则三 （特别注明：一定要注意的是 readLine() 是否有定义，有什么比 read, write 更特殊的输入或输出方法） 第六，是否要格式化输出：原则二","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://bestsonic.github.io/tags/Java/"},{"name":"IO流","slug":"IO流","permalink":"http://bestsonic.github.io/tags/IO流/"}]},{"title":"Java笔记-JDBC","slug":"Java笔记-JDBC","date":"2015-07-27T02:30:00.000Z","updated":"2017-07-30T07:00:40.000Z","comments":true,"path":"2015/07/27/Java笔记-JDBC/","link":"","permalink":"http://bestsonic.github.io/2015/07/27/Java笔记-JDBC/","excerpt":"JDBC是JAVA操作数据库的基本技术，并不是唯一技术。本文将对Java JDBC编程进行总结，希望能对大家有所帮助。 Hibernate、TopLink等OR Mapping操作数据库的技术都是建立JDBC技术之上的，实际来说，他们的性能和JDBC是有很大差距的，但反过来说，如果JDBC用不好，还不如hibernate呢。暂且不说这些孰优孰劣的话了，再次主要是对Java的基础技术做个总结，以加深认识。","text":"JDBC是JAVA操作数据库的基本技术，并不是唯一技术。本文将对Java JDBC编程进行总结，希望能对大家有所帮助。 Hibernate、TopLink等OR Mapping操作数据库的技术都是建立JDBC技术之上的，实际来说，他们的性能和JDBC是有很大差距的，但反过来说，如果JDBC用不好，还不如hibernate呢。暂且不说这些孰优孰劣的话了，再次主要是对Java的基础技术做个总结，以加深认识。 JDBC的基本原理 JDBC是Java操作数据库的技术规范。他实际上定义了一组标准的操作数据库的接口。为了能让Java操作数据库，必须要有实现了JDBC这些接口的类，不同的数据库厂商为了让Java语言能操作自己的数据库，都提供了对JDBC接口的实现–这些实现了JDBC接口的类打成一个jar包，就是我们平时看到的数据库驱动。由于不同的数据库操作数据的机制不一样，因此JDBC的具体实现也就千差万别，但是你作为java程序员，你只和Java JDBC的接口打交到，才不用理会他们怎么实现的！呵呵，现在知道JDBC驱动是怎么回事了。 JDBC驱动的四种类型Java中的JDBC驱动可以分为四种类型，包括JDBC-ODBC桥、本地API驱动、网络协议驱动和本地协议驱动。 JDBC驱动类型一——JDBC-ODBC桥 JDBC-ODBC 桥 是sun公司提供的，是jdk提供的的标准API. 这种类型的驱动实际是把所有 JDBC的调用传递给ODBC ,再由ODBC调用本地数据库驱动代码.( 本地数据库驱动代码是指 由数据库厂商提供的数据库操作二进制代码库,例如在oracle for windows中就是oci dll 文 件) 只要本地机装有相关的ODBC驱动那么采用JDBC-ODBC桥几乎可以访问所有的数据库,JDBC- ODBC方法对于客户端已经具备ODBC driver的应用还是可行的. 但是,由于JDBC-ODBC先调用 ODBC再由ODBC去调用本地数据库接口访问数据库.所以,执行效率比较低,对于那些大数据量 存取的应用是不适合的.而且,这种方法要求客户端必须安装ODBC 驱动,所以对于基于 internet ,intranet的应用也是不合适的.因为,你不可能要求所有客户都能找到ODBC driver. JDBC驱动类型二——本地API驱动 本地API驱动直接把JDBC调用转变为数据库的标准调用再去访问数据库. 这种方法需要本地 数据库驱动代码. 本地API驱动 | 厂商DB代码—————数据库Server (图二) 这种驱动比起JDBC-ODBC桥执行效率大大提高了.但是,它仍然需要在客户端加载数据库厂商 提供的代码库.这样就不适合基于internet的应用.并且,他的执行效率比起3,4型的JDBC驱动 还是不够高. JDBC驱动类型三——网络协议驱动 这种驱动实际上是根据我们熟悉的三层结构建立的. JDBC先把对数局库的访问请求传递给网 络上的中间件服务器. 中间件服务器再把请求翻译为符合数据库规范的调用,再把这种调用 传给数据库服务器.如果中间件服务器也是用java开法的,那么在在中间层也可以使用1,2型 JDBC驱动程序作为访问数据库的方法. 网络协议驱动———中间件服务器————数据库Server 由于这种驱动是基于server的.所以,它不需要在客户端加载数据库厂商提供的代码库.而且 他在执行效率和可升级性方面是比较好的.因为大部分功能实现都在server端,所以这种驱动 可以设计的很小,可以非常快速的加载到内存中. 但是,这种驱动在中间件层仍然需要有配置 其它数据库驱动程序,并且由于多了一个中间层传递数据,它的执行效率还不是最好. JDBC驱动类型四——本地协议驱动 这种驱动直接把JDBC调用转换为符合相关数据库系统规范的请求.由于4型驱动写的应用可 以直接和数据库服务器通讯.这种类型的驱动完全由java实现,因此实现了平台独立性. 本地协议驱动———数据库Server 由于这种驱动不需要先把JDBC的调用传给ODBC或本地数据库接口或者是中间层服务器.所 以它的执行效率是非常高的.而且,它根本不需要在客户端或服务器端装载任何的软件或驱动. 这种驱动程序可以动态的被下载.但是对于不同的数据库需要下载不同的驱动程序. 以上对四种类型的JDBC驱动做了一个说明.那么它们适合那种类型的应用开发呢? JDBC-ODBC桥由于它的执行效率不高,更适合做为开发应用时的一种过度方案,或着对于初学 者了解JDBC编程也较适用. 对于那些需要大数据量操作的应用程序则应该考虑2,3,4型驱动.在intranet方面的应用可以 考虑2型驱动,但是由于3,4型驱动在执行效率上比2型驱动有着明显的优势,而且目前开发 的趋势是使用纯java.所以3,4型驱动也可以作为考虑对象. 至于基于internet方面的应用就只有考虑3,4型驱动了. 因为3型驱动可以把多种数据库驱 动都配置在中间层服务器.所以3型驱动最适合那种需要同时连接多个不同种类的数据库, 并且对并发连接要求高的应用. 4型驱动则适合那些连接单一数据库的工作组应用。 JDBC编程流程 为了说明这个步骤，假设你要通过java程序执行一个sql查询，你需要按照如下的流程去走： 创建指定数据库的URL这个URL实际上还是统一资源定位器，里面包含了一些连接数据库的信息：数据库类型、端口、驱动类型、连接方式、数据库服务器的ip(或名字)、数据库名（有的是别名）等。其格式如下： 1jdbc:subProtocol:subName://DBserverIP:port/DatabaseName 例如mysql的一个url： 1jdbc:mysql://192.168.3.143:3306/zfvims 加载驱动类到JVM内存区域中有两种方法： 一种是用Class.forName()方法加载指定的驱动程序。推荐这种方法，不会对具体的驱动类产生依赖。 一种是DriverManager.registerDriver(new com.mysql.jdbc.Driver())方法。这种方法会两次注册驱动，而且对具体的驱动依赖。 一种是System.setProperty(“jdbc.drivers”, “driver1:driver2”)方法，将驱动程序添加到java.lang.System的属性jdbc.drivers中。注册不太方便。 最后说明一点，有时候添加到系统的CLASSPATH环境变量是不行的，原因是在使用JDBC接口操作数据库前，JVM还没有加载上驱动。 1Class.forName(\"com.mysql.jdbc.Driver\"); 通过DriverManager类管理驱动、创建数据库连接DriverManager类作用于程序员和JDBC驱动程序之间，提供注册管理驱动建立连接细节等方法，它所有成员均为静态的。通过其getConnection方法会创建一个JDBC Connection对象。 1Connection conn=DriverManager.registerDriver(\"jdbc:mysql://192.168.3.143:3306/zfvims\",\"lavasoft\",\"password\"); Connection类——数据库连接1Connection conn = DriverManager.getConnection(url, user, password); url格式：JDBC:子协议:子名称//主机名:端口/数据库名？属性名=属性值&amp;… User,password可以用“属性名=属性值”方式告诉数据库； 其他参数如：useUnicode=true&amp;characterEncoding=GBK。 这里所说的Connection类实际上是实现了JDBC的Connection接口的类，这个类一般都是jdbc驱动程序实现了。Connection类表示了数据库连接，通过其对象可以获取一个获取数据库和表等数据库对象的详细信息。但更多的是通过这个连接更进一步去向数据库发送SQL语句去执行，下面会讲到。 数据库的连接的建立是很耗费资源和时间的，因此在不用连接的情况下要通过其close()方法将连接关闭，以释放系统资源。 Statement类——发送并执行（静态）SQL语句Statement是一个SQL执行器，可以用来执行一个静态的SQL语句。通过Connection对象的createStatement()方法可以创建一个Statement对象，通过该对象的方法可以（发送）并执行一个静态sql语句。如果要执行动态的sql（sql串中有参数），那么就用PreparedStatement类，用法和Statement类似。 12Statement st = con.createStatement();st.executeQuery(sql); PreparedStatement是一个与定义的SQL执行器，一般较Statement有防止SQL注入的功能，还有较好的执行效率。 1234String sql = \"select * from table_name where col_name=?\";PreparedStatement ps = conn.preparedStatement(sql);ps.setString(1, \"col_value\");ps.executeQuery(); 在数据库连接没有关闭的情况下，数据库和驱动可以对PreperedStatement进行优化，PreperedStatement对象可以被重用，从而避免频繁编译SQL。 ResultSet类——结果集当你执行一条sql查询后，就会产生一个查询结果。ResultSet就表示数据库结果集的数据表，通常通过执行查询数据库的语句生成。ResultSet 对象具有指向其当前数据行的指针。通过ResultSet对象不但可以结果集数据，还可以获取结果集表的列名、数据类型等信息。 123456ResultSet rs = statement.executeQuery(sql);While(rs.next())&#123; rs.getString(“col_name”); rs.getInt(“col_name”); //…&#125; 关闭数据库连接当对sql操作完成后，应该关闭数据库连接，这样避免因为连接未关闭而耗费系统资源，如果每次都不关闭，多次操作将建立多个连接，最终数据库连接会达到最大限度，或者耗尽系统的资源，从而导致应用崩溃。因此要注意关闭资源，尤其是数据库连接。 释放资源的顺序是ResultSet, Statement,Connection; Connection在使用完成后，必须关闭，ResultSet, Statement无所谓，只要Connection关闭了，它们也会被自动关闭（但资源不是立即被释放）。 Connection的使用原则是尽量晚创建，尽量早的释放。 在关闭资源异常的情况下，应该将资源赋null值，以确保资源最大可能的被释放掉。 几种特殊且比较常用的类型 DATA,TIME,TIMESTAMP date,time,datetime 存：ps.setDate(i,d); ps.setTime(i,t); ps.setTimestamp(i, ts); 取：rs.getDate(i); rs.getTime(i); rs.getTimestamp(i); CLOB text 存：ps.setCharacterStream(index, reader, length); ps.setString(i, s); 取：reader = rs. getCharacterStream(i); reader = rs.getClob(i).getCharacterStream(); string = rs.getString(i); BLOB blob 存：ps.setBinaryStream(i, inputStream, length); 取：rs.getBinaryStream(i); rs.getBlob(i).getBinaryStream(); JDBC编程实例 下面通过一个执行一条简单的MySQL查询来说名上面的JDBC编程的一般方法和步骤。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class TestJDBC()&#123; public static Connection getConnectionByJDBC() &#123; Connection conn = null; try &#123; //装载驱动类 Class.forName(\"com.mysql.jdbc.Driver\"); &#125; catch (ClassNotFoundException e) &#123; System.out.println(\"装载驱动异常!\"); e.printStackTrace(); &#125; try &#123; //建立JDBC连接 conn = DriverManager.getConnection(\"\"jdbc:mysql://192.168.3.143:3306/zfvims\",\"lavasoft\",\"password\"); &#125; catch (SQLException e) &#123; System.out.println(\"链接数据库异常!\"); e.printStackTrace(); &#125; return conn; &#125; public static String test() &#123; String sqlx = \"select t.code,t.name from province t order by t.code asc\"; try &#123; //创建一个JDBC声明 Statement stmt = conn.createStatement(ResultSet.TYPE_FORWARD_ONLY, ResultSet.CONCUR_READ_ONLY); //执行查询 ResultSet = stmt.executeQuery(sqlx); while (rs.next()) &#123; String code = rs.getString(\"code\"); String name = rs.getString(\"name\"); System.out.println(code+name); &#125; &#125; catch (SQLException e) &#123; System.out.println(e.getMessage()); e.printStackTrace(); &#125; finally &#123; //预防性关闭连接（避免异常发生时在try语句块关闭连接没有执行） try &#123; if (conn != null) conn.close(); &#125; catch (SQLException e) &#123; System.out.println(e.getMessage()); e.printStackTrace(); &#125; &#125; &#125; public static void main(String args[]) &#123; new TestJDBC().test(); &#125; &#125; 事务的隔离级别 更新遗失(Lost update) 两个事务都同时更新一行数据，但是第二个事务却中途失败退出，导致对数据的两个修改都失效了。这是因为系统没有执行任何的锁操作，因此并发事务并没有被隔离开来。 基本上就是指某个事务对字段进行更新的信息，因另一个事务的介入而遗失更新效力。举例来说，若某个字段数据原为 ZZZ，用户 A、B 分别在不同的时间点对同一字段进行更新事务，如下图： 单就用户 A 的事务而言，最后字段应该是 OOO，单就用户 B 的事务而言，最后字段应该是 ZZZ。在完全没有隔离两者事务的情况下，由于用户 B 撤销操作时间在用户 A 确认之后，因此最后字段结果会 是ZZZ，用户A看不到他新确认 的OOO 结果，用 户A 发生更新遗失问题。 如果要避免更新遗失问题，需要设置隔离级别为“可读取未确认”（Read Uncommitted），如果一个事务已经开始写数据，则另外一个数据则不允许同时进行写操作，但允许其他事务读此行数据。 该隔离级别可通过“排他写锁”实现。JDBC 可通过 Connection 的 setTransactionIsolation() 设置为 TRANSACTION_UNCOMMITTED 来提示数据库指定此隔离行为。 实现后如下图： 提示数据库“可读取未确认”的隔离层次之后，数据库至少得保证事务能避免更新遗失问题，通常这也是具备事务功能的数据库引擎会采取的最低隔离层级。不过这个隔离层级读取错误数据的机率太高，一般默认不会采用这种隔离级别。 脏读（Dirty read） 两个事务同时进行，其中一个事务更新数据但未确认，另一个事务就读取数据，就有可能发生脏读问题，也就是读到所谓脏数据、不干净、不正确的数据。如下图： 如果要避免脏读问题，可以设置隔离层级为“可读取确认”(Read committed)。这可以通过“瞬间共享读锁”和“排他写锁”实现。读取数据的事务允许其他事务继续访问该行数据，但是未提交的写事务将会禁止其他事务访问该行。也就是事务读取的数据必须是其他事务已确认的数据。JDBC 可通过 Connection 的 setTransactionIsolation() 设置为 TRANSACTION_COMMITTED 来提示数据库指定此隔离行为。 实现后如下图所示： 提示数据库“可读取确认”的隔离层次之后，数据库至少得保证事务能避免脏读与更新遗失问题。 无法重复的读取（Unrepeatable read） 某个事务两次读取同一字段的数据并不一致。如下图： 如果要避免无法重复的读取问题， 可以设置隔离层级为“可重复读取”(Repeatable read)，这可以通过“共享读锁”和“排他写锁”实现。读取数据的事务将会禁止写事务（但允许读事务），写事务则禁止任何其他事务。也就是同一事务内两次读取的数据必须相同。JDBC 可通过 Connection 的 setTransactionIsolation() 设置为 TRANSACTION_REPEATABLE_READ 来提示数据库指定此隔离行为。 实现后如下图所示： 在数据库上这个做法影响性能较大，另一个基本做法是事务正在读取但尚未确认前，另一事务会在暂存表格上更新。提示数据库“可重复读取”的隔离层次之后，数据库至少得保证事务能避免无法重复读取、脏读与更新遗失问题。 幻读(Phantom read) 同一事务期间，读取到的数据笔数不一致。例如，事务 A 第一次读取得到五笔数据，此时事务 B 新增了一笔数据，导致事务 B 再次读取得到六笔数据。 如果隔离行为设置为可重复读取，但发生幻读现象，可以设置隔离层级为“可循序”(Serializable)，它要求事务序列化执行，事务只能一个接着一个地执行，但不能并发执行。如果仅仅通过“行级锁”是无法实现事务序列化的，必须通过其他机制保证新插入的数据不会被刚执行查询操作的事务访问到。也就是在有事务时若有数据不一致的疑虑，事务必须可以按照顺序逐一进行。JDBC 可通过 Connection 的 setTransactionIsolation() 设置为 TRANSACTION_SERIALIZABLE 来提示数据库指定此隔离行为。 隔离级别越高，越能保证数据的完整性和一致性，但是对并发性能的影响也越大。对于多数应用程序，可以优先考虑把数据库系统的隔离级别设为 Read Committed。它能够避免脏读取，而且具有较好的并发性能。尽管它会导致不可重复读、虚读和第二类丢失更新这些并发问题，在可能出现这类问题的个别场合，可以由应用程序采用悲观锁或乐观锁来控制。 隔离行为 更新遗失 脏读 无法重复读取 幻读 可读取未确认 Read Uncommitted 预防 可读取确认 Read Uncommitted 预防 预防 可重复读取 Repeatable read 预防 预防 可循序 Serializable 预防 预防 预防 数据库事务的ACID特性 原子性(Atomicity) 整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。 例如：银行刷卡业务，当消费的时候 A 顾客的卡钱减少，然后 B 商城的账户加钱，只有当这 2 个操作都成功的时候才可以进行提交，否则都必须回滚。这就是事务的原子性，因为这 2 个操作不可以分开。 一致性(Consistency) 在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。 例如：有表 A 和表 B，表 A 中的一个字段 aa 是表 B 中 bb 字段的外键，并且 bb 字段是必填的，当在 B 表中插入数据的时候如果 bb 字段的值在 A 表中没有，则事务必须回滚否则会破坏数据库的完整性约束。 隔离性(Isolation) 两个事务的执行是互不干扰的，一个事务不可能看到其他事务运行时，中间某一时刻的数据。 例如：A 顾客银行卡刷的钱与 B 顾客互相不影响。 持久性(Durability) 在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。 例如：在A顾客消费成功后，银行卡的钱不可以被回滚。 JDBC事务编程 我们已经知道，事务的概念即：所有的操作要么同时成功，要么同时失败。在MySQL中提供了Commit、Rollback命令进行事务的提交与回滚。实际上在JDBC中也存在事务处理，如果要想进行事务处理的话，则必须按照以下的步骤完成。 JDBC中事务处理的步骤： 要取消掉JDBC的自动提交：void setAutoCommit(boolean autoCommit) 执行各个SQL语句，加入到批处理之中 如果所有语句执行成功，则提交事务 commit()；如果出现了错误，则回滚：rollback() 核心代码： 12345678910conn.setAutoCommit(false); // 取消自动提交把SQL语句加入批处理stmt.addBatch(…) ()stmt.addBatch(…)//执行批处理操作stmt.executeBatch();conn.commit(); // 提交事务//如果发生错误conn.rollback(); 代码举例： 首先在sql中创建一个空的数据库，现在在java中，使用PreparedStatement插入数据并修改数据。正常情况下，代码应该这样写： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.vae.jdbc;import java.sql.Connection;import java.sql.DriverManager;import java.sql.PreparedStatement;import java.sql.ResultSet;import java.sql.SQLException;public class JDBCtest &#123; //数据库连接地址 public final static String URL = \"jdbc:mysql://localhost:3306/JDBCdb\"; //用户名 public final static String USERNAME = \"root\"; //密码 public final static String PASSWORD = \"smyh\"; //驱动类 public final static String DRIVER = \"com.mysql.jdbc.Driver\"; public static void main(String[] args) &#123; //insert(p); //update(p); //delete(3); insertAndQuery(); &#125; //方法：使用PreparedStatement插入数据、更新数据 public static void insertAndQuery()&#123; Connection conn = null; try &#123; Class.forName(DRIVER); conn = DriverManager.getConnection(URL, USERNAME, PASSWORD); String sql1 = \"insert into user(name,pwd)values(?,?)\"; String sql2 = \"update user set pwd=? where name=?\"; PreparedStatement ps = conn.prepareStatement(sql1); ps.setString(1, \"smyhvae\"); ps.setString(2, \"007\"); ps.executeUpdate(); ps = conn.prepareStatement(sql2); ps.setString(1, \"008\"); ps.setString(2, \"smyh\"); ps.executeUpdate(); ps.close(); conn.close(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 事务处理： 现在我们把上面的插入操作和修改操作变成一个事务，就要增加一部分代码了。修改上方的insertAndQuery()方法里面的代码： 12345678910111213141516171819202122232425262728293031323334//方法：使用PreparedStatement插入数据、更新数据public static void insertAndQuery()&#123; Connection conn = null; try &#123; Class.forName(DRIVER); conn = DriverManager.getConnection(URL, USERNAME, PASSWORD); conn.setAutoCommit(false);//设置为手动提交事务 String sql1 = \"insert into user(name,pwd)values(?,?)\"; String sql2 = \"update user set pwd=? where name=?\"; PreparedStatement ps = conn.prepareStatement(sql1); ps.setString(1, \"smyhvae\"); ps.setString(2, \"007\"); ps.executeUpdate(); ps = conn.prepareStatement(sql2); ps.setString(1, \"008\"); ps.setString(2, \"smyh\"); ps.executeUpdate(); conn.commit(); //如果所有sql语句成功，则提交事务 ps.close(); conn.close(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (SQLException e) &#123; e.printStackTrace(); try &#123; conn.rollback();//只要有一个sql语句出现错误，则将事务回滚 &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; &#125;&#125; 核心代码是第07行、19行、28行。这三行代码就完成了事务处理的操作。两个sql语句中，只要有一个语句出现错误，程序将无法运行，说明事务提交失败，且报错如下：","categories":[],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"http://bestsonic.github.io/tags/JDBC/"},{"name":"Java","slug":"Java","permalink":"http://bestsonic.github.io/tags/Java/"}]},{"title":"Java数据库开发专题","slug":"Java数据库开发专题","date":"2015-07-25T02:30:00.000Z","updated":"2017-07-30T07:00:46.000Z","comments":true,"path":"2015/07/25/Java数据库开发专题/","link":"","permalink":"http://bestsonic.github.io/2015/07/25/Java数据库开发专题/","excerpt":"Java 和数据库相结合后所产生的能量相当惊人。然而，要使它们结合工作却颇费周折 —— 这主要是因为 Java 处理的是对象，而大多数数据库却并不如此。通过学习本专题所提供的技术文章和教程，您将了解到使用 Java 技术进行数据管理和持久化开发诸多模式和技巧，以及如何利用 ORM 工具或对象数据库来简化数据库开发。","text":"Java 和数据库相结合后所产生的能量相当惊人。然而，要使它们结合工作却颇费周折 —— 这主要是因为 Java 处理的是对象，而大多数数据库却并不如此。通过学习本专题所提供的技术文章和教程，您将了解到使用 Java 技术进行数据管理和持久化开发诸多模式和技巧，以及如何利用 ORM 工具或对象数据库来简化数据库开发。 Java 数据管理和持久性综述 J2EE 应用程序中的数据管理和数据持久性 本文分析了在 Java 平台上可用的两个数据管理策略：Java 对象序列化和 Java 数据库连接（JDBC）。轻量级开发的成功秘诀：持久性策略 在任何 Java 技术应用程序中，持久性框架都是一个极其重要的部分。作出选择是令人头疼的一件事。因此，开发人员常常选择流行的框架，不论是企业级 JavaBeans 还是 Hibernate。本文讨论各种方案并给您一个选择最佳方案的方法。 J2EE 与 IBM 对象-关系数据库 本文简要地介绍了 J2EE 环境，并讨论了 J2EE 开发中使用的面向对象方法（分析、设计、实现），以及一些与对象持久性相关的问题。 持久化模式 高级 DAO 编程 J2EE 开发人员使用数据访问对象(Data Access Object DAO)设计模式，以便将低级别的数据访问逻辑与高级别的业务逻辑分离。本文讨论了 DAO 编程中三个常常被忽略的方面：事务界定、异常处理和日志记录。 持久化模式，第 1 部分: 现代 ORM 工具的策略和最佳实践 尽管有许多开发人员使用对象-关系映射（ORM）工具构造应用程序的持久化层，但是也有一些开发人员对于如何使用这些工具有误解，常常不必要地重复编写代码。本文作者在构造持久化层方面具有丰富的经验，他们对持久化模式和最佳实践有清晰的认识。第 1 部分讨论一致且紧凑的领域模型和持久化层的基本概念。 持久化模式，第 2 部分: 提高代码重用和改进性能 在第 2 部分中，作者将描述基领域实体、领域模型中的行为以及泛型 DAO 的高级特性，还要提供改进领域模型的数据获取性能的策略。 JDBC（Java DataBase Connectivity） 使用 JDBC 来创建数据库对象 本文分析了 Java DataBase Connectivity (JDBC)，一个在 Java 中以面向对象的方法来联接数据库的技术。 一个简单的 JDBC 包装器 本文描述了一种简单的包装器库，它让使用简单的数据库易如反掌。您会发现您已经开始想在编写的每一个程序中都使用 JDBC。 对一个简单的 JDBC 包装器的扩展及应用 本文将对《一个简单的 JDBC 包装器》中的JDBC包装器进行一些扩展，然后介绍一下其在 JSP/JavaBean 开发模式中的应用。 JDBC，详解 Java 的灵活性为您提供了几种与数据库连接和交互的方法。本文将概述其中一种方法：开发针对 DB2 使用 Java 数据库连接（JDBC）API 的 Java 应用程序和 applet。 JDBC 查询日志变得简单 JDBC java.sql.PreparedStatement 接口的简单扩展可以使查询日志更少犯错，同时整理您的代码。在本文中，作者向您介绍如何应用基本的封装技术(“通过封装来实现扩展”也称为 Decorator设计模式)来获得最满意的结果。 实战 Groovy: 用 Groovy 进行 JDBC 编程 GroovySql 结合利用闭包（closure）和迭代器（iterator），把资源管理的负担转移到 Groovy 框架本身，从而简化了 Java 数据库连通性（Java Database Connectivity，JDBC）的编程。 Java SE 6 新特性: Java DB 和 JDBC 4.0 本系列文章主要介绍 Java SE 6 在 API 库方面的部分新特性，通过一些例子和讲解，帮助开发者在编程实践当中更好的运用 Java SE 6，提高开发效率。本文介绍了 Java SE 6 在数据库编程方面的新特性。 使用 Java 5 RowSet 新特性访问 IBM DB2 数据库 Java 5 在 Java Database Connectivity (JDBC) 方面加强了支持，其中加入了新的包 javax.sql.rowset，javax.sql.rowset.serial，javax.sql.rowset.spi。本文将通过实例来演示这些新的特性。 Java 6 RowSet 使用完全剖析 javax.sql.rowset 包下定义了五个不同的 RowSet 接口，供不同的场合使用。本文将分别对这五个 RowSet 的使用场合以及详尽用法进行介绍。 性能优化 Java 访问数据库的速度瓶颈问题的分析及解决 本文分析了 Java 访问数据库的瓶颈问题，并给出了相应的解决办法。 高速缓存和连接池对访问数据库性能的影响 本文在介绍高速缓存和连接池的基础上，给出解决数据库性能问题的一些有用办法。 基于 JDBC 的数据库连接池高效管理策略 本文在对数据库连接进行透彻分析的基础上，提出并实现了一个高效的连接管理策略，使得开发高性能的数据库应用变得相对容易。 使用Java 中的动态代理实现数据库连接池 作者通过使用 JAVA 中的动态代理实现数据库连接池，使使用者可以以普通的 JDBC 连接的使用习惯来使用连接池。 Web 开发人员：为最佳性能而进行优化？ 如果您在开发 Web 应用程序，那么您很可能熟悉基于Java连接到数据库的方法：JDBC 和 SQLJ。但是您知道如何能让使用这些方法的应用程序获得最佳性能吗？ 监控业务系统数据库连接 本文分析了业务模块如何导致系统级别的问题，并提出了实时监控数据库连接细节并准确定位异常所在模块的方法，以方便排除业务模块问题。 教程：在使用 SQLJ 和 JDBC 时获取最优的 DB2 性能 本教程介绍了 SQLJ 和 JDBC 的知识，并对它们进行了比较。除此之外，本教程还讨论了一些方法，以使您的 Java 程序在访问 DB2 时达到最佳性能。 诊断 DB2 Java 应用程序的性能问题 从应用程序客户机的角度诊断和隔离性能问题。本文学习如何为在 IBM DB2 for Linux, UNIX, and Windows 数据库上运行的 Java 应用程序排除性能问题。 在 J2EE Web Application 中快速高效访问 IBM DB2 数据库 本文首先介绍如何快速的利用 IBM DB2 提供的 JDBC 驱动程序通过 Java API 进行数据库接口开发，然后进一步介绍如何在 WebSphere Application Server 6.0 中配置数据库连接池 (Connection Pool)，更加高效地访问 IBM DB2 数据库，最后通过一致的代码接口，使得 Web 开发人员更加透明的访问 IBM DB2 数据库。 Java ORM 框架 使用 EJB 3.0 Java Persistence API 设计企业应用程序 JPA 提供了一种标准的对象关系映射解决方案，该解决方案避免了依赖第三方框架（如 Hibernate）。您将看到示例应用程序的详细内容，其中验证了本方法并阐明关键设计决定。 教程：Spring 2 和 JPA 简介 Java 持久性 API （JPA）这是企业 JavaBean（EJB）3.0 规范的基石。在这份教程中，您将学习如何用 Spring 2 框架从头开始创建服务器应用程序。 专家评论: Roland Barcia：Java Persistence API 中带注释的命名查询是否真的非常有用？ 在 Java Persistence API (JPA) 中，注释用作将 Java 对象映射到底层数据库的一种机制，不过即使在注释没有任何意义时，开发人员也常常使用它。本文介绍通过 JPA 访问数据的一些其他方法，以及这些方法作为最佳选择的时间和原因。 Hibernate使用 Hibernate 来实现持久对象 本文介绍如何在 Web 应用开发中配置 Hibernate 的环境，并且使用 Hibernate 来开发一个具体的实例。 在 Hibernate 中实现复杂的数据映射 在本文，将介绍怎么在 Hibernate 中描述多个表的映射关系，并且演示怎么操作关系复杂的持久对象。 无需容器的对象关系映射 本文用一个真实世界的例子向您介绍两个最激动人心的企业新技术。Hibernate 是一个对象关系映射工具，而 Spring 是一个 AOP 框架和 IOC 容器。本文介绍了如何结合这两者，为企业应用程序构建一个事务持久层。 Hibernate 简化继承映射 本文将介绍三个策略，在日常的编程之中您可以用它们把复杂的对象模型容易地映射到关系数据库模型。 Hibernate 配置文件在单元测试中的灵活运用 本文讨论了 Hibernate 加载其配置文件 hibernate.properties 和 hibernate.cfg.xml 的过程，以及怎么样将 Hibernate 提供的配置文件的访问方法灵活运用到单元测试中。 使用 Hibernate 将 Java 对象持久保存到 IBM DB2 通用数据库中 Hibernate 是一个开放源码应用程序，提供了一种轻易地将 Java 对象持久保存到 DB2 通用数据库的方法。本文为您描述了其具体的使用过程。 iBatisRoland Barcia：厌烦了人工编码 JDBC？改用 iBatis 数据映射框架吧！ 如果您厌烦了编写 JDBC，可以考虑使用另一个功能丰富的数据映射框架 iBatis，它能够实现大多数同样的功能，并且只需要编写非常少的代码。 扩展 iBatis 以透明支持多种数据库 iBatis 是一个开源的对象关系映射框架，着重于 POJO 与 SQL 之间的映射关系。本文提供了一个简单有效的方法，通过扩展 iBatis 来透明地支持多数据库方言。 JDO教程：Java 数据对象上机实践 Java 数据对象（Java Data Objects (JDO)）是 Sun Microsystems 的一项新技术。本教程中，我们将使用讨论、代码样本以及上机练习来了解有关 JDO 的实际应用。 TriActive JDO 实用简介 TriActive JDO (TJDO) 是 Sun Java Data Objects (JDO) 1.0 规范的一个轻型的、开放源代码的实现。本文将通过一个例子介绍 TJDO，这个例子示范了如何在 MySQL 数据库中持久存储域模型。 通过 JPOX 和 DB2 Universal Database 了解 JDO 2.0 本文介绍了如何使用 Java Persistent Objects (JPOX) 将乏味的存取数据 SQL 语句的编写工作抽象为对象操作。我们展示了 JPOX 1.1，它被 Java Community Process 选作 Java Data Ojects 2.0 的参考实现。 JDO 技术分析及企业应用研究 JDO（Java Data Object）是 JCP 中较早开发出来并形成规范的 JSR-12，该规范对数据的持久化存储进行了一系列规范，并已有众多的商业产品和开源项目是基于该规范。作为一种需要引起重视的技术，研究并探讨其企业应用可行性是十分重要的。 Simple Persistence for JavaSimple Persistence for Java 的零配置对象持久性 Simple Persistence for Java 是一个开源的对象关系型持久性库，它使用定制查询语言以及内建数据库支持来简化 Java 应用程序中的对象持久性。在本文中，软件架构师 Sami Salkosuo 介绍了该库，并带您领略解决对象持久性的零管理以及零配置方法。","categories":[],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"http://bestsonic.github.io/tags/JDBC/"},{"name":"数据库开发","slug":"数据库开发","permalink":"http://bestsonic.github.io/tags/数据库开发/"}]},{"title":"软件设计的一些原则(转)","slug":"软件设计的一些原则","date":"2015-07-23T13:30:00.000Z","updated":"2017-07-30T07:00:12.000Z","comments":true,"path":"2015/07/23/软件设计的一些原则/","link":"","permalink":"http://bestsonic.github.io/2015/07/23/软件设计的一些原则/","excerpt":"以下文章转自：酷 壳 – CoolShell.cn 以前本站向大家介绍过一些软件开发的原则，比如优质代码的十诫和Unix传奇(下篇)中所以说的UNIX的设计原则。相信大家从中能够从中学了解到一些设计原理方面的知识，正如我在《再谈“我是怎么招聘程序”》中所说的，一个好的程序员通常由其操作技能、知识水平，经验层力和能力四个方面组成。在这里想和大家说说设计中的一些原则，我认为这些东西属于长期经验总结出来的知识。这些原则，每一个程序员都应该了解。但是请不要教条主义，在使用的时候还是要多多考虑实际情况。其实，下面这些原则，不单单只是软件开发，可以推广到其它生产活动中，甚至我们的生活中。","text":"以下文章转自：酷 壳 – CoolShell.cn 以前本站向大家介绍过一些软件开发的原则，比如优质代码的十诫和Unix传奇(下篇)中所以说的UNIX的设计原则。相信大家从中能够从中学了解到一些设计原理方面的知识，正如我在《再谈“我是怎么招聘程序”》中所说的，一个好的程序员通常由其操作技能、知识水平，经验层力和能力四个方面组成。在这里想和大家说说设计中的一些原则，我认为这些东西属于长期经验总结出来的知识。这些原则，每一个程序员都应该了解。但是请不要教条主义，在使用的时候还是要多多考虑实际情况。其实，下面这些原则，不单单只是软件开发，可以推广到其它生产活动中，甚至我们的生活中。 Don’t Repeat Yourself (DRY) DRY 是一个最简单的法则，也是最容易被理解的。但它也可能是最难被应用的（因为要做到这样，我们需要在泛型设计上做相当的努力，这并不是一件容易的事）。它意味着，当我们在两个或多个地方的时候发现一些相似的代码的时候，我们需要把他们的共性抽象出来形一个唯一的新方法，并且改变现有的地方的代码让他们以一些合适的参数调用这个新的方法。 参考：http://en.wikipedia.org/wiki/Don%27t_repeat_yourself Keep It Simple, Stupid (KISS) KISS原则在设计上可能最被推崇的，在家装设计，界面设计 ，操作设计上，复杂的东西越来越被众人所BS了，而简单的东西越来越被人所认可，比如这些UI的设计和我们中国网页（尤其是新浪的网页）者是负面的例子。“宜家”（IKEA）简约、效率的家居设计、生产思路；“微软”（Microsoft）“所见即所得”的理念；“谷歌”（Google)简约、直接的商业风格，无一例外的遵循了“kiss”原则，也正是“kiss”原则，成就了这些看似神奇的商业经典。而苹果公司的iPhone/iPad将这个原则实践到了极至。 把一个事情搞复杂是一件简单的事，但要把一个复杂的事变简单，这是一件复杂的事。 参考：http://en.wikipedia.org/wiki/KISS_principle Program to an interface, not an implementation 这是设计模式中最根本的哲学，注重接口，而不是实现，依赖接口，而不是实现。接口是抽象是稳定的，实现则是多种多样的。以后面我们会面向对象的SOLID原则中会提到我们的依赖倒置原则，就是这个原则的的另一种样子。还有一条原则叫 Composition over inheritance（喜欢组合而不是继承），这两条是那23个经典设计模式中的设计原则。 Command-Query Separation (CQS) – 命令-查询分离原则 查询：当一个方法返回一个值来回应一个问题的时候，它就具有查询的性质； 命令：当一个方法要改变对象的状态的时候，它就具有命令的性质； 通常，一个方法可能是纯的Command模式或者是纯的Query模式，或者是两者的混合体。在设计接口时，如果可能，应该尽量使接口单一化，保证方法的行为严格的是命令或者是查询，这样查询方法不会改变对象的状态，没有副作用，而会改变对象的状态的方法不可能有返回值。也就是说：如果我们要问一个问题，那么就不应该影响到它的答案。实际应用，要视具体情况而定，语义的清晰性和使用的简单性之间需要权衡。将Command和Query功能合并入一个方法，方便了客户的使用，但是，降低了清晰性，而且，可能不便于基于断言的程序设计并且需要一个变量来保存查询结果。 在系统设计中，很多系统也是以这样原则设计的，查询的功能和命令功能的系统分离，这样有则于系统性能，也有利于系统的安全性。 参考：http://en.wikipedia.org/wiki/Command-query_separation You Ain’t Gonna Need It (YAGNI) 这个原则简而言之为——只考虑和设计必须的功能，避免过度设计。只实现目前需要的功能，在以后您需要更多功能时，可以再进行添加。 如无必要，勿增复杂性。 软件开发先是一场沟通博弈。 以前本站有一篇关于过度重构的文章，这个示例就是这个原则的反例。而WebSphere的设计者就表示过他过度设计了这个产品。我们的程序员或是架构师在设计系统的时候，会考虑很多扩展性的东西，导致在架构与设计方面使用了大量折衷，最后导致项目失败。这是个令人感到讽刺的教训，因为本来希望尽可能延长项目的生命周期，结果反而缩短了生命周期。 参考：http://en.wikipedia.org/wiki/You_Ain%27t_Gonna_Need_It Law of Demeter – 迪米特法则 迪米特法则(Law of Demeter)，又称“最少知识原则”（Principle of Least Knowledge），其来源于1987年荷兰大学的一个叫做Demeter的项目。Craig Larman把Law of Demeter又称作“不要和陌生人说话”。在《程序员修炼之道》中讲LoD的那一章叫作“解耦合与迪米特法则”。关于迪米特法则有一些很形象的比喻： 如果你想让你的狗跑的话，你会对狗狗说还是对四条狗腿说？ 如果你去店里买东西，你会把钱交给店员，还是会把钱包交给店员让他自己拿？ 和狗的四肢说话？让店员自己从钱包里拿钱？这听起来有点荒唐，不过在我们的代码里这几乎是见怪不怪的事情了。 对于LoD，正式的表述如下： 对于对象 ‘O’ 中一个方法’M’，M应该只能够访问以下对象中的方法： 对象O； 与O直接相关的Component Object； 由方法M创建或者实例化的对象； 作为方法M的参数的对象。 在《Clean Code》一书中，有一段Apache framework中的一段违反了LoD的代码： final String outputDir = ctxt.getOptions().getScratchDir().getAbsolutePath(); 这么长的一串对其它对象的细节，以及细节的细节，细节的细节的细节……的调用，增加了耦合，使得代码结构复杂、僵化，难以扩展和维护。 在《重构》一书中的代码的环味道中有一种叫做“Feature Envy”(依恋情结），形象的描述了一种违反了LoC的情况。Feature Envy就是说一个对象对其它对象的内容更有兴趣，也就是说老是羡慕别的对象的成员、结构或者功能，大老远的调用人家的东西。这样的结构显然是不合理的。我们的程序应该写得比较“害羞”。不能像前面例子中的那个不把自己当外人的店员一样，拿过客人的钱包自己把钱拿出来。“害羞”的程序只和自己最近的朋友交谈。这种情况下应该调整程序的结构，让那个对象自己拥有它羡慕的feature，或者使用合理的设计模式（例如Facade和Mediator）。 参考：http://en.wikipedia.org/wiki/Principle_of_Least_Knowledge 面向对象的S.O.L.I.D 原则 一般来说这是面向对象的五大设计原则，但是，我觉得这些原则可适用于所有的软件开发。 Single Responsibility Principle (SRP) – 职责单一原则关于单一职责原则，其核心的思想是：一个类，只做一件事，并把这件事做好，其只有一个引起它变化的原因。单一职责原则可以看作是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。职责过多，可能引起它变化的原因就越多，这将导致职责依赖，相互之间就产生影响，从而极大的损伤其内聚性和耦合度。单一职责，通常意味着单一的功能，因此不要为一个模块实现过多的功能点，以保证实体只有一个引起它变化的原因。 Unix/Linux是这一原则的完美体现者。各个程序都独立负责一个单一的事。 Windows是这一原则的反面示例。几乎所有的程序都交织耦合在一起。 Open/Closed Principle (OCP) – 开闭原则关于开发封闭原则，其核心的思想是：模块是可扩展的，而不可修改的。也就是说，对扩展是开放的，而对修改是封闭的。 对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。 对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对类进行任何修改。 对于面向对象来说，需要你依赖抽象，而不是实现，23个经典设计模式中的“策略模式”就是这个实现。对于非面向对象编程，一些API需要你传入一个你可以扩展的函数，比如我们的C 语言的qsort()允许你提供一个“比较器”，STL中的容器类的内存分配，ACE中的多线程的各种锁。对于软件方面，浏览器的各种插件属于这个原则的实践。 Liskov substitution principle (LSP) – 里氏代换原则软件工程大师Robert C. Martin把里氏代换原则最终简化为一句话：“Subtypes must be substitutable for their base types”。也就是，子类必须能够替换成它们的基类。即：子类应该可以替换任何基类能够出现的地方，并且经过替换以后，代码还能正常工作。另外，不应该在代码中出现if/else之类对子类类型进行判断的条件。里氏替换原则LSP是使代码符合开闭原则的一个重要保证。正是由于子类型的可替换性才使得父类型的模块在无需修改的情况下就可以扩展。 这么说来，似乎有点教条化，我非常建议大家看看这个原则个两个最经典的案例——“正方形不是长方形”和“鸵鸟不是鸟”。通过这两个案例，你会明白《墨子 小取》中说的 ——“娣，美人也，爱娣，非爱美人也….盗，人也；恶盗，非恶人也。”——妹妹虽然是美人，但喜欢妹妹并不代表喜欢美人。盗贼是人，但讨厌盗贼也并不代表就讨厌人类。这个原则让你考虑的不是语义上对象的间的关系，而是实际需求的环境。 在很多情况下，在设计初期我们类之间的关系不是很明确，LSP则给了我们一个判断和设计类之间关系的基准：需不需要继承，以及怎样设计继承关系。 Interface Segregation Principle (ISP) – 接口隔离原则接口隔离原则意思是把功能实现在接口中，而不是类中，使用多个专门的接口比使用单一的总接口要好。 举个例子，我们对电脑有不同的使用方式，比如：写作，通讯，看电影，打游戏，上网，编程，计算，数据等，如果我们把这些功能都声明在电脑的抽类里面，那么，我们的上网本，PC机，服务器，笔记本的实现类都要实现所有的这些接口，这就显得太复杂了。所以，我们可以把其这些功能接口隔离开来，比如：工作学习接口，编程开发接口，上网娱乐接口，计算和数据服务接口，这样，我们的不同功能的电脑就可以有所选择地继承这些接口。 这个原则可以提升我们“搭积木式”的软件开发。对于设计来说，Java中的各种Event Listener和Adapter，对于软件开发来说，不同的用户权限有不同的功能，不同的版本有不同的功能，都是这个原则的应用。 Dependency Inversion Principle (DIP) – 依赖倒置原则高层模块不应该依赖于低层模块的实现，而是依赖于高层抽象。 举个例子，墙面的开关不应该依赖于电灯的开关实现，而是应该依赖于一个抽象的开关的标准接口，这样，当我们扩展程序的时候，我们的开关同样可以控制其它不同的灯，甚至不同的电器。也就是说，电灯和其它电器继承并实现我们的标准开关接口，而我们的开关产商就可不需要关于其要控制什么样的设备，只需要关心那个标准的开关标准。这就是依赖倒置原则。 这就好像浏览器并不依赖于后面的web服务器，其只依赖于HTTP协议。这个原则实在是太重要了，社会的分工化，标准化都是这个设计原则的体现。 参考：http://en.wikipedia.org/wiki/Solid_(object-oriented_design)) Common Closure Principle（CCP）– 共同封闭原则 一个包中所有的类应该对同一种类型的变化关闭。一个变化影响一个包，便影响了包中所有的类。一个更简短的说法是：一起修改的类，应该组合在一起（同一个包里）。如果必须修改应用程序里的代码，我们希望所有的修改都发生在一个包里（修改关闭），而不是遍布在很多包里。CCP原则就是把因为某个同样的原因而需要修改的所有类组合进一个包里。如果2个类从物理上或者从概念上联系得非常紧密，它们通常一起发生改变，那么它们应该属于同一个包。 CCP延伸了开闭原则（OCP）的“关闭”概念，当因为某个原因需要修改时，把需要修改的范围限制在一个最小范围内的包里。 参考：http://c2.com/cgi/wiki?CommonClosurePrinciple Common Reuse Principle (CRP) – 共同重用原则 包的所有类被一起重用。如果你重用了其中的一个类，就重用全部。换个说法是，没有被一起重用的类不应该被组合在一起。CRP原则帮助我们决定哪些类应该被放到同一个包里。依赖一个包就是依赖这个包所包含的一切。当一个包发生了改变，并发布新的版本，使用这个包的所有用户都必须在新的包环境下验证他们的工作，即使被他们使用的部分没有发生任何改变。因为如果包中包含有未被使用的类，即使用户不关心该类是否改变，但用户还是不得不升级该包并对原来的功能加以重新测试。 CCP则让系统的维护者受益。CCP让包尽可能大（CCP原则加入功能相关的类），CRP则让包尽可能小（CRP原则剔除不使用的类）。它们的出发点不一样，但不相互冲突。 参考：http://c2.com/cgi/wiki?CommonReusePrinciple Hollywood Principle – 好莱坞原则 好莱坞原则就是一句话——“don’t call us, we’ll call you.”。意思是，好莱坞的经纪人们不希望你去联系他们，而是他们会在需要的时候来联系你。也就是说，所有的组件都是被动的，所有的组件初始化和调用都由容器负责。组件处在一个容器当中，由容器负责管理。 简单的来讲，就是由容器控制程序之间的关系，而非传统实现中，由程序代码直接操控。这也就是所谓“控制反转”的概念所在： 不创建对象，而是描述创建对象的方式。 在代码中，对象与服务没有直接联系，而是容器负责将这些联系在一起。 控制权由应用代码中转到了外部容器，控制权的转移，是所谓反转。 好莱坞原则就是IoC（Inversion of Control）或DI（Dependency Injection ）的基础原则。这个原则很像依赖倒置原则，依赖接口，而不是实例，但是这个原则要解决的是怎么把这个实例传入调用类中？你可能把其声明成成员，你可以通过构造函数，你可以通过函数参数。但是 IoC可以让你通过配置文件，一个由Service Container 读取的配置文件来产生实际配置的类。但是程序也有可能变得不易读了，程序的性能也有可能还会下降。 参考： http://en.wikipedia.org/wiki/Hollywood_Principle http://en.wikipedia.org/wiki/Inversion_of_Control High Cohesion &amp; Low/Loose coupling &amp; – 高内聚， 低耦合 这个原则是UNIX操作系统设计的经典原则，把模块间的耦合降到最低，而努力让一个模块做到精益求精。 内聚：一个模块内各个元素彼此结合的紧密程度 耦合：一个软件结构内不同模块之间互连程度的度量 内聚意味着重用和独立，耦合意味着多米诺效应牵一发动全身。 参考： http://en.wikipedia.org/wiki/Coupling_(computer_science) http://en.wikipedia.org/wiki/Cohesion_(computer_science) Convention over Configuration（CoC）– 惯例优于配置原则 简单点说，就是将一些公认的配置方式和信息作为内部缺省的规则来使用。例如，Hibernate的映射文件，如果约定字段名和类属性一致的话，基本上就可以不要这个配置文件了。你的应用只需要指定不convention的信息即可，从而减少了大量convention而又不得不花时间和精力啰里啰嗦的东东。配置文件很多时候相当的影响开发效率。 Rails 中很少有配置文件（但不是没有，数据库连接就是一个配置文件），Rails 的fans号称期开发效率是 java 开发的 10 倍，估计就是这个原因。Maven也使用了CoC原则，当你执行mvn -compile命令的时候，不需要指源文件放在什么地方，而编译以后的class文件放置在什么地方也没有指定，这就是CoC原则。 参考：http://en.wikipedia.org/wiki/Convention_over_Configuration Separation of Concerns (SoC) – 关注点分离 SoC 是计算机科学中最重要的努力目标之一。这个原则，就是在软件开发中，通过各种手段，将问题的各个关注点分开。如果一个问题能分解为独立且较小的问题，就是相对较易解决的。问题太过于复杂，要解决问题需要关注的点太多，而程序员的能力是有限的，不能同时关注于问题的各个方面。正如程序员的记忆力相对于计算机知识来说那么有限一样，程序员解决问题的能力相对于要解决的问题的复杂性也是一样的非常有限。在我们分析问题的时候，如果我们把所有的东西混在一起讨论，那么就只会有一个结果——乱。 我记得在上一家公司有一个项目，讨论就讨论了1年多，项目本来不复杂，但是没有使用SoC，全部的东西混为一谈，再加上一堆程序员注入了各种不同的观点和想法，整个项目一下子就失控了。最后，本来一个1年的项目做了3年。 实现关注点分离的方法主要有两种，一种是标准化，另一种是抽象与包装。标准化就是制定一套标准，让使用者都遵守它，将人们的行为统一起来，这样使用标准的人就不用担心别人会有很多种不同的实现，使自己的程序不能和别人的配合。Java EE就是一个标准的大集合。每个开发者只需要关注于标准本身和他所在做的事情就行了。就像是开发镙丝钉的人只专注于开发镙丝钉就行了，而不用关注镙帽是怎么生产的，反正镙帽和镙丝钉按标来就一定能合得上。不断地把程序的某些部分抽像差包装起来，也是实现关注点分离的好方法。一旦一个函数被抽像出来并实现了，那么使用函数的人就不用关心这个函数是如何实现的，同样的，一旦一个类被抽像并实现了，类的使用者也不用再关注于这个类的内部是如何实现的。诸如组件，分层，面向服务，等等这些概念都是在不同的层次上做抽像和包装，以使得使用者不用关心它的内部实现细节。 说白了还是“高内聚，低耦合”。 参考：http://sulong.me/archives/99 Design by Contract (DbC) – 契约式设计 DbC的核心思想是对软件系统中的元素之间相互合作以及“责任”与“义务”的比喻。这种比喻从商业活动中“客户”与“供应商”达成“契约”而得来。例如： 供应商必须提供某种产品（责任），并且他有权期望客户已经付款（权利）。 客户必须付款（责任），并且有权得到产品（权利）。 契约双方必须履行那些对所有契约都有效的责任，如法律和规定等。 同样的，如果在程序设计中一个模块提供了某种功能，那么它要： 期望所有调用它的客户模块都保证一定的进入条件：这就是模块的先验条件（客户的义务和供应商的权利，这样它就不用去处理不满足先验条件的情况）。 保证退出时给出特定的属性：这就是模块的后验条件——（供应商的义务，显然也是客户的权利）。 在进入时假定，并在退出时保持一些特定的属性：不变式。 契约就是这些权利和义务的正式形式。我们可以用“三个问题”来总结DbC，并且作为设计者要经常问： 它期望的是什么？ 它要保证的是什么？ 它要保持的是什么？ 根据Bertrand Meyer氏提出的DBC概念的描述，对于类的一个方法，都有一个前提条件以及一个后续条件，前提条件说明方法接受什么样的参数数据等，只有前提条件得到满足时，这个方法才能被调用；同时后续条件用来说明这个方法完成时的状态，如果一个方法的执行会导致这个方法的后续条件不成立，那么这个方法也不应该正常返回。 现在把前提条件以及后续条件应用到继承子类中，子类方法应该满足： 前提条件不强于基类． 后续条件不弱于基类． 换句话说，通过基类的接口调用一个对象时，用户只知道基类前提条件以及后续条件。因此继承类不得要求用户提供比基类方法要求的更强的前提条件，亦即，继承类方法必须接受任何基类方法能接受的任何条件（参数）。同样，继承类必须顺从基类的所有后续条件，亦即，继承类方法的行为和输出不得违反由基类建立起来的任何约束，不能让用户对继承类方法的输出感到困惑。 这样，我们就有了基于契约的LSP，基于契约的LSP是LSP的一种强化。 参考：http://en.wikipedia.org/wiki/Design_by_contract Acyclic Dependencies Principle (ADP) – 无环依赖原则 包之间的依赖结构必须是一个直接的无环图形，也就是说，在依赖结构中不允许出现环（循环依赖）。如果包的依赖形成了环状结构，怎么样打破这种循环依赖呢？有2种方法可以打破这种循环依赖关系：第一种方法是创建新的包，如果A、B、C形成环路依赖，那么把这些共同类抽出来放在一个新的包D里。这样就把C依赖A变成了C依赖D以及A依赖D，从而打破了循环依赖关系。第二种方法是使用DIP（依赖倒置原则）和ISP（接口分隔原则）设计原则。 无环依赖原则（ADP）为我们解决包之间的关系耦合问题。在设计模块时，不能有循环依赖。 参考：http://c2.com/cgi/wiki?AcyclicDependenciesPrinciple 总结 上面这些原则可能有些学院派，也可能太为理论，我在这里说的也比较模糊和简单，这里只是给大家一个概貌，如果想要了解更多的东西，大家可以多google一下。 不过这些原则看上去都不难，但是要用好却并不那么容易。要能把这些原则用得好用得精，而不教条，我的经验如下：（我以为这是一个理论到应用的过程） 你可以先粗浅或是表面地知道这些原则。 但不要急着马上就使用。 在工作学习中观察和总结别人或自己的设计。 再回过头来了回顾一下这些原则，相信你会有一些自己的心得。 有适度地去实践一下。 Goto第 3步。 我相信可能还会有其他一些原则，欢迎大家提供。","categories":[],"tags":[{"name":"软件开发","slug":"软件开发","permalink":"http://bestsonic.github.io/tags/软件开发/"},{"name":"设计原则","slug":"设计原则","permalink":"http://bestsonic.github.io/tags/设计原则/"}]},{"title":"GitHub-Hexo博客部署","slug":"GitHub-Hexo博客部署","date":"2015-07-21T13:30:00.000Z","updated":"2017-07-30T07:00:23.000Z","comments":true,"path":"2015/07/21/GitHub-Hexo博客部署/","link":"","permalink":"http://bestsonic.github.io/2015/07/21/GitHub-Hexo博客部署/","excerpt":"今天无意中看到了Hexo这个基于Node.js博客框架，自称轻巧快速，并与Jekyll/Octopress有着很好的兼容性，基本能够做到无痛移植，于是就又动起了折腾的想法。 尝试后感觉Hexo确实很不错，与Octopress很相似，但生成静态页面的速度比Octopress要快的多，而且搭建环境也要容易的多。之前的文章也是把文件直接复制过来就OK了，很赞。 这里简单介绍一下Hexo的安装和使用方法，详细的文档包括API都可以在官网找到(看域名是台湾人的作品)。","text":"今天无意中看到了Hexo这个基于Node.js博客框架，自称轻巧快速，并与Jekyll/Octopress有着很好的兼容性，基本能够做到无痛移植，于是就又动起了折腾的想法。 尝试后感觉Hexo确实很不错，与Octopress很相似，但生成静态页面的速度比Octopress要快的多，而且搭建环境也要容易的多。之前的文章也是把文件直接复制过来就OK了，很赞。 这里简单介绍一下Hexo的安装和使用方法，详细的文档包括API都可以在官网找到(看域名是台湾人的作品)。 快速体验Hexo 首先安装Git。 1https://git-scm.com/ Hexo的安装十分便捷，我们先尝试快速的使用Hexo搭建一个站点。 首先安装Node.js，这里使用nvm作为node版本控制的文件。最好不要直接apt-get，版本不对可能会有问题。 12wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | shnvm install 0.10 接下来使用npm工具安装hexo。(在任意位置点击鼠标右键，选择Git bash) 1npm install -g hexo 初始化hexo文件夹。 安装完成后，在你喜爱的文件夹下（如D:\\hexo），执行以下指令(在D:\\hexo内点击鼠标右键，选择Git bash)，Hexo 即会自动在目标文件夹建立网站所需要的所有文件。 1$ hexo init &lt;folder&gt; &amp;&amp; cd &lt;folder&gt; M安装依赖包。 1npm install 生成静态页面并预览。 1$ hexo g &amp;&amp; hexo s OK，在浏览器中输入localhost:4000，一个Hexo站点就已经展示在你面前了！是不是特别容易？相比Octopress，搭建环境不是方便了一点点。 了解Hexo 当然，以上只是使用Hexo搭建了一个站点，要想使用它，还需要多了解一些东西。 目录结构Hexo的目录结构如下，其中_config.yml是整个站点的配置文件，source/_drafts是草稿文件目录，source/_posts是发表的博文目录，themes是下载的主题目录，其它的目录暂时不用管。 123456789. ├── _config.yml ├── package.json ├── scaffolds ├── scripts ├── source | ├── _drafts | └── _posts └── themes 首先是修改配置文件，主要就是配置一下自己的站点信息，配置文件中的注释比较详细，如果不懂的话可以=&gt;点这里&lt;=看一下,在预览状态下改的话网页上能即时看到效果。 安装插件和主题 Hexo提供丰富的插件以及主题，安装方法都是一样的。更多的主题可以在这里下载。 插件: 1$ npm install &lt;plugin-name&gt; --save 主题: 1$ git clone &lt;repository&gt; themes/&lt;theme-name&gt; 无论是插件还是主题在安装后都需要在根目录下_config.yml中修改plugins和theme的值以启用他们。 部署到GitHub上 注册Repository首先注册GitHub账号。已有账号可以跳过，没有的，请在此进行注册，很简单，这里就不介绍了。 在自己GitHub主页右上角点击那个+号，创建一个新的repository。比如我的GitHub账号是Bestsonic，那么我应该创建的repository名字应该是Bestsonic.github.io。 切记GitHub的用户名是什么博客的名称就是什么。如果你博客名称跟Github的名称不一致是不允许通过的，除非你创建了其他用户的时候把branch:master分支换成gh-pages是GitHub为了web项目特别设置的分支。 Hexo部署接着，可以将hexo部署到GitHub上。 编辑_config.yml(在D:\\hexo下)。你在部署时，要把下面的Bestsonic都换成你的账号名。 1234deploy:type: gitrepository: git@github.com:Bestsonic/Bestsonic.github.com.gitbranch: master 注意：Hexo更新到3.0后，deploy的type由github变成了git。 在配置type: git后，在运行hexo d部署时，可能会出现error deployer not found:git。这时需要在Git bash中输入 1npm install hexo-deployer-git --save 如果你是为一个项目制作网站，那么需要把branch设置为gh-pages。若要绑定自定义域名也可以参考Hexo或Github Page的帮助文档，制作一个cname文件。 之后执行下列指令即可完成部署，注意部署会覆盖掉你之前在版本库中存放的文件。 123hexo cleanhexo generatehexo deploy 或可加入 —generate 选项，在部署前自动生成文件。 1hexo deploy --generate 其原理就是hexo在执行hexo generate时会在本地先把博客生成的一套静态站点放到public文件夹中，在执行hexo deploy时将其复制到.deploy文件夹中。Github的版本库通常建议同时附上README.md说明文件，但是hexo默认情况下会把所有md文件解析成html文件，所以即使你在线生成了README.md，它也会在你下一次部署时被删去。怎么解决呢？ 在执行hexo deploy前把在本地写好的README.md文件复制到.deploy文件夹中，再去执行hexo deploy。 GitHub部署SSH有些新用户需要设置 ssh，否则上述命令会失败。具体过程如下： 12$ cd ~/.ssh# Checks to see if there is a directory named \".ssh\" in your user directory 使用ssh-keygen命令产生新的key 1234$ ssh-keygen -t rsa -C \"your_email@example.com\"# Creates a new ssh key using the provided emailGenerating public/private rsa key pair.Enter file in which to save the key (/home/you/.ssh/id_rsa): 使用默认的文件名，直接enter，按提示输入密码（如果不提供密码，SSH将无密码连接，如果private key泄露可能会有安全问题） 12Enter passphrase (empty for no passphrase): [Type a passphrase]Enter same passphrase again: [Type passphrase again] 密匙产生成功:1234Your identification has been saved in /home/you/.ssh/id_rsa.Your public key has been saved in /home/you/.ssh/id_rsa.pub.The key fingerprint is:01:0f:f4:3b:ca:85:d6:17:a1:7d:f0:68:9d:f0:a2:db your_email@example.com 接下来，只要上传public key到GitHub账户即可。 使用以下命令测试是否能连接github服务器，如果显示以下语句，则表明配置成功： 12$ ssh -T git@github.comHi Bestsonic! You've successfully authenticated, but GitHub does not provide shell access. 这个过程可能会碰到提示没有配置username和email，按提示配置即可。 记住：每次修改本地文件后，需要hexo generate才能保存。每次使用命令时，都要在D:\\hexo目录下。 Ok,我们的博客已经完全搭建起来了，在浏览器访问Bestsonic.github.io就能看到你的成就了！ 常用Hexo命令 Hexo的常用命令有以下几个 12345$ hexo new [layout] &lt;title&gt; #建立新文章，默认在_posts下，layout=\"draft\"时发布的是草稿$ hexo publish &lt;filename&gt; #将_drafts下的文件放到_posts下，也就是发布草稿$ hexo generate #生成静态网页$ hexo server #启动预览服务器，开启-d选项时可以预览草稿$ hexo deploy #发布到远程服务器，开启--generate选项可以在deploy前自动generate 熟悉Octopress的话应该有时曾相识的感觉，Hexo和Octopress的操作基本是一样的，但是它的generate确实快上很多。。 此外，Hexo还提供了以上几个命令的简化版本，可以减少输入。 12345$ hexo n # == hexo new$ hexo p # == hexo publish$ hexo g # == hexo generate$ hexo s # == hexo server$ hexo d # == hexo deploy 使用MarkDown语法写博客 和Octopress完全一样，使用Markdown语法编辑文章。 使用hexo new命令生成文章或者直接在_posts目录下直接创建文件，打开后先编辑文章头部信息，如下所示是本文的头部信息，以—结尾。 12345678910---title: 使用Hexo搭建个人博客layout: postdate: 2014-03-03 19:07:43comments: truecategories: Blogtags: [Hexo]keywords: Hexo, Blogdescription: 生命在于折腾，又把博客折腾到Hexo了。给Hexo点赞。--- 接下来使用Markdown编辑文章就可以了。 注意事项 关于摘要如果你之前使用过jekyll那么可能这一切都很熟悉。hexo的文章保存在source/_post目录下。在文档中插入就可以将文章分隔，more以上的部分会已摘要的形式显示，当查看全文时more以下的部分才会显示出来。也可以在Markdown文件中定义description。 图片显示同样放到source目中下。建议大家建立一个image文件夹，把文章中使用到的图片丢到这里来（当然可以按照你的习惯进行分类），之后在Markdown文件中按照这样的语法进行插入图片的操作。 1![图片描述文字](/image/图片名.jpg) 自定义页面如果想建立一个简单的Page很容易，只需要在source下建立一个文件夹，如page。在这个目录下新建index.md：12345---title: Pagedate: 2013-12-26 22:52:56---This is a page test. 最后在你的主题目录下找到主题的配置文件_config.yml，在里面配置页面的路径即可。 so easy?那么如果我放一些不需要hexo帮我解析的HTML文件(比如404页面)呢？ 在source下放入一个HTML文件，hexo还是会自作多情的用render帮你解析了。这个时候需要在html文件的头部加入: 12layout: false--- 好吧，我的静态页面比较多，不想在每个html页面头部加入layout定义。那你可以修改主题的layout.ejs文件。 123456789&lt;% if(page.layout=='page')&#123; %&gt; &lt;% if(page.source.match(/\\.md$/))&#123; %&gt; 原来的内容 &lt;% &#125;else&#123; %&gt; &lt;%- page.content %&gt; &lt;% &#125; %&gt;&lt;% &#125;else&#123; %&gt;原来的内容&lt;% &#125; %&gt; 这样你放入source文件夹中的html页面就会被hexo忽略掉。 实时预览如今的Hexo已经可以自动监控文件修改，并为你自动更新。如果连刷新都懒得去按怎么办？ 使用livereload。 livereload不仅仅跨平台，而且是开源的，可以使用npm安装，同时提供包括自动编译Less、Stylus或集成Sublime Text等编辑器的插件。神器在手妈妈再也不用担心我的F5键了。 使用MarkDown编辑器推荐一款好用的MarkDown编辑器：Atom 下载地址：https://atom.io/ Atom软件的使用，可以参考这里。 MarkDown语法，请见GitHub 风格的 Markdown 语法、Markdown 语法说明。 其他Tip 有的时候当你修改页面或更改配置后发现并没有立即生效，可以执行hexo clean然后再启动hexo server。 默认的评论组件可能并不太适合中国大陆用户（你懂的。。），你可以选择性的换成别的组件，或主题，比如我用的多说评论以及Pacman主题。 参与开源项目很简单，你只需要学会使用Git以及Github，遇到bug或任何程序问题可以递交issue，当然如果你有能力自己解决问题或可以为Hexo开发新的功能，那么请pull request。","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"http://bestsonic.github.io/tags/Git/"},{"name":"Hexo","slug":"Hexo","permalink":"http://bestsonic.github.io/tags/Hexo/"}]}]}